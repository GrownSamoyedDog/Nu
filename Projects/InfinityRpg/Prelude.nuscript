; Nu Game Engine.
; Copyright (C) Bryan Edds, 2013-2017.

#| The unit type indicator.             |# [define -u- []]
#| The bool type indicator.             |# [define -b- false]
#| The int type indicator.              |# [define -i- 0]
#| The int64 type indicator.            |# [define -L- 0L]
#| The single type indicator.           |# [define -f- 0f]
#| The double type indicator.           |# [define -d- 0d]
#| The string type indicator.           |# [define -s- ""]
#| The keyword type indicator.          |# [define -k- nil]
#| The tuple type indicator.            |# [define -u- [tuple]]
#| The keyphrase type indicator.        |# [define -p- [nil]]
#| The option type indicator.           |# [define -o- none]
#| The list type indicator.             |# [define -l- [list]]
#| The ring type indicator.             |# [define -r- [ring]]
#| The table type indicator.            |# [define -t- [table]]

#| Check that a value is unit.          |# [define isUnit [a] [= [typename a] "Unit"]]
#| Check that a value is a bool.        |# [define isBool [a] [= [typename a] "Bool"]]
#| Check that a value is a int.         |# [define isInt [a] [= [typename a] "Int"]]
#| Check that a value is a int64.       |# [define isInt64 [a] [= [typename a] "Int64"]]
#| Check that a value is a single.      |# [define isSingle [a] [= [typename a] "Single"]]
#| Check that a value is a double.      |# [define isDouble [a] [= [typename a] "Double"]]
#| Check that a value is a string.      |# [define isString [a] [= [typename a] "String"]]
#| Check that a value is a keyword.     |# [define isKeyword [a] [= [typename a] "Keyword"]]
#| Check that a value is a tuple.       |# [define isTuple [a] [= [typename a] "Tuple"]]
#| Check that a value is a keyphrase.   |# [define isKeyphrase [a] [= [typename a] "Keyphrase"]]
#| Check that a value is a option.      |# [define isOption [a] [= [typename a] "Option"]]
#| Check that a value is a list.        |# [define isList [a] [= [typename a] "List"]]
#| Check that a value is a ring.        |# [define isRing [a] [= [typename a] "Ring"]]
#| Check that a value is a table.       |# [define isTable [a] [= [typename a] "Table"]]

; The identity function.
[define id [a] a]

; Flip a binary function's arguments.
[define flip [f]
    [fun [a b] [f b a]]]

; Determine that a value is its identity.
[define isIdentity [a]
    [= a [toIdentity a]]]

; Check that a value is positive.
[define isPositive [a]
    [>= a [toEmpty a]]]

; Check that a value is negative.
[define isNegative [a]
    [<= a [toEmpty a]]]

; Check that a value is positive infinity.
[define isPositiveInfinity [a]
    [> a [toMax a]]]

; Check that a value is negative infinity.
[define isNegativeInfinity [a]
    [< a [toMin a]]]

; Check that a value is IEEE not-a-number.
[define isNaN [a]
    [|| [isPositiveInfinity a]
        [isNegativeInfinity a]]]

; Select the mininum value.
[define min [a b]
    [if [< a b] a b]]

; Select the maximum value.
[define max [a b]
    [if [> a b] a b]]

; Compare two values. Returns Lt, Gt, or Eq.
[define compare [a b]
    [if [< a b]
        Lt
        [if [> a b] Gt Eq]]]

; The sign of a value. Returns Positive, Negative, or Zero.
[define sign [a]
    [if [> a [toEmpty a]]
        Positive
        [if [< a [toEmpty a]] Negative Zero]]]

; Compute the absolute value.
[define abs [a]
    [if [isNegative a]
        [negate a]
        a]]

; Dereference a structure, then get its first item.
[define fst! [a]
    [fst [! a]]]

; Dereference a structure, then get its second item.
[define snd! [a]
    [snd [! a]]]

; Reverse the elements in a container.
[define rev [ctr]
    [fold [flip cons] [toEmpty ctr] ctr]]

; Fold over a container backward while state satisfies the given predicate.
[define foldBackWhile [folder state ctr]
    [foldWhile folder state [rev ctr]]]

; Fold over a container backward, providing the reverse index of each element.
[define foldBacki [folder state ctr]
    [foldi folder state [rev ctr]]]

; Fold over a container backward.
[define foldBack [folder state ctr]
    [fold folder state [rev ctr]]]

; Reduce a container with at least one element while the reducer function returns some.
[define reduceWhile [reducer ctr]
    [let [pr [split ctr]]
         [foldWhile reducer [fst pr] [snd pr]]]]

; Reduce a container with at least one element, providing the index of each element.
[define reducei [reducer ctr]
    [let [pr [split ctr]]
         [foldi reducer [fst pr] [snd pr]]]]

; Reduce a container with at least one element.
[define reduce [reducer ctr]
    [let [pr [split ctr]]
         [fold reducer [fst pr] [snd pr]]]]

; Get only the some elements of a container.
[define definitize [ctr]
    [foldBack
        [fun [elems elemOpt] [if [isSome elemOpt] [cons [! elemOpt] elems] elems]]
        [toEmpty ctr]
        ctr]]

; Filter for elements that satifsy the given predicate.
[define filter [pred ctr]
    [foldBack
        [fun [elems elem] [if [pred elem] [cons elem elems] elems]]
        [toEmpty ctr]
        ctr]]

; Build a container of elements taken from the given container while a predicate succeeds.
[define takeWhile [pred ctr]
    [rev
        [foldWhile
            [fun [elems elem] [if [pred elem] [some [cons elem elems]] none]]
            [toEmpty ctr]
            ctr]]]

[define take3 [current n ctr]
    [let [opt [tryUncons ctr]]
         [if [&& [isSome opt] [< current n]]
             [cons [fst! opt] [take3 [inc current] n [snd! opt]]]
             [toEmpty ctr]]]]

; Build a container of n elements taken from the given container, skipping n elements.
; NOTE: this can blow the stack when n is very large.
[define take [n ctr]
    [take3 0 n ctr]]

; Build a container of elements taken from the given container, skipping elements while a predicate succeeds.
[define skipWhile [pred ctr]
    [rev [snd [foldWhile
        [fun [pr elem]
            [let [taken [fst pr]]
                 [elems [snd pr]]
                 [if taken
                     [some [pair taken [cons elem elems]]]
                     [if [pred elem]
                         [some [pair false elems]]
                         [some [pair true [cons elem elems]]]]]]]
        [pair false [toEmpty ctr]]
        ctr]]]]

[define skip3 [current n ctr]
    [let [opt [tryUncons ctr]]
         [if [isSome opt]
             [if [< current n]
                 [skip3 [inc current] n [snd! opt]]
                 [cons [fst! opt] [skip3 current n [snd! opt]]]]
             ctr]]]

; Build a container of elements taken from the given container, skipping n elements.
; NOTE: this can blow the stack when n is very large.
[define skip [n ctr]
    [skip3 0 n ctr]]

; Count the number of a container's element that satisfies the given predicate.
[define countBy [pred ctr]
    [fold [fun [count elem] [if [pred elem] [inc count] count]] 0 ctr]]

; Count the number of a container's element that equal the value.
[define count [a ctr]
    [fold [fun [count elem] [if [= elem a] [inc count] count]] 0 ctr]]

; Determine whether a container doesn't hold the given element.
[define notContains [pred ctr]
    [not [contains pred ctr]]]

; Determine that a container holds an element that satisfies the given predicate.
[define exists [pred ctr]
    [fold
        [fun [exist elem] [|| exist [pred elem]]]
        false
        ctr]]

; Determine whether a container doesn't hold an element that satisfies the given predicate.
[define notExists [pred ctr]
    [not [exists pred ctr]]]

; Zip two containers by the given zipper function.
; NOTE: will blow stack when both containers are very large.
[define zipBy [zipper ctr ctr2]
     [let [opt [tryUncons ctr]]
          [opt2 [tryUncons ctr2]] 
          [if [|| [isNone opt] [isNone opt2]]
              [toEmpty ctr]
              [cons [zipper [fst! opt] [fst! opt2]]
                    [zipBy zipper [snd! opt] [snd! opt2]]]]]]

; Zip two containers into a container of pairs.
[define zip [ctr ctr2]
    [zipBy pair ctr ctr2]]

; Mathematical constant pi as a single value.
[define pi 3.14159f]

; Mathematical constant e as a single value.
[define e 2.71828f]

#| Nu Script Extensions. TODO: import Prelude.script rather than pasting it above? |#

[define toEmpty_Vector2 [_] [v2 0f 0f]]
[define toIdentity_Vector2 [_] [v2 1f 1f]]
[define toMin_Vector2 [_] [v2 [toMin -s-] [toMin -s-]]]
[define toMax_Vector2 [_] [v2 [toMax -s-] [toMax -s-]]]
[define inc_Vector2 [v] [v2 [inc [xOf v]] [inc [yOf v]]]]
[define dec_Vector2 [v] [v2 [dec [xOf v]] [dec [yOf v]]]]
[define negate_Vector2 [v] [v2 [negate [xOf v]] [negate [yOf v]]]]
[define pow_Vector2 [v] [v2 [pow [xOf v]] [pow [yOf v]]]]
[define root_Vector2 [v] [v2 [root [xOf v]] [root [yOf v]]]]
[define sqr_Vector2 [v] [v2 [sqr [xOf v]] [sqr [yOf v]]]]
[define sqrt_Vector2 [v] [v2 [sqrt [xOf v]] [sqrt [yOf v]]]]
[define floor_Vector2 [v] [v2 [floor [xOf v]] [floor [yOf v]]]]
[define ceiling_Vector2 [v] [v2 [ceiling [xOf v]] [ceiling [yOf v]]]]
[define truncate_Vector2 [v] [v2 [truncate [xOf v]] [truncate [yOf v]]]]
[define round_Vector2 [v] [v2 [round [xOf v]] [round [yOf v]]]]
[define exp_Vector2 [v] [v2 [exp [xOf v]] [exp [yOf v]]]]
[define log_Vector2 [v] [v2 [log [xOf v]] [log [yOf v]]]]
[define sin_Vector2 [v] [v2 [sin [xOf v]] [sin [yOf v]]]]
[define cos_Vector2 [v] [v2 [cos [xOf v]] [cos [yOf v]]]]
[define tan_Vector2 [v] [v2 [tan [xOf v]] [tan [yOf v]]]]
[define asin_Vector2 [v] [v2 [asin [xOf v]] [asin [yOf v]]]]
[define acos_Vector2 [v] [v2 [acos [xOf v]] [acos [yOf v]]]]
[define atan_Vector2 [v] [v2 [atan [xOf v]] [atan [yOf v]]]]
[define length_Vector2 [v] [sqrt [+ [atan [xOf v]] [atan [yOf v]]]]
[define normal_Vector2 [v] [/ v [length v]]]

[define =_Vector2 [v w] [&& [= [xOf v] [xOf w]] [= [xOf v] [xOf w]]]]
[define <>_Vector2 [v w] [&& [<> [xOf v] [xOf w]] [<> [xOf v] [xOf w]]]]
[define <_Vector2 [v w] [&& [< [xOf v] [xOf w]] [< [xOf v] [xOf w]]]]
[define >_Vector2 [v w] [&& [> [xOf v] [xOf w]] [> [xOf v] [xOf w]]]]
[define <=_Vector2 [v w] [&& [<= [xOf v] [xOf w]] [<= [xOf v] [xOf w]]]]
[define >=_Vector2 [v w] [&& [>= [xOf v] [xOf w]] [>= [xOf v] [xOf w]]]]
[define +_Vector2 [v w] [v2 [+ [xOf v] [xOf w]] [+ [xOf v] [xOf w]]]]
[define -_Vector2 [v w] [v2 [- [xOf v] [xOf w]] [- [xOf v] [xOf w]]]]
[define *_Vector2 [v w] [v2 [* [xOf v] [xOf w]] [* [xOf v] [xOf w]]]]
[define /_Vector2 [v w] [v2 [/ [xOf v] [xOf w]] [/ [xOf v] [xOf w]]]]
[define %_Vector2 [v w] [v2 [% [xOf v] [xOf w]] [% [xOf v] [xOf w]]]]
[define dot_Vector2 [v w] [+ [* [xOf v] [xOf w]] [* [yOf v] [yOf w]]]]

; The v2 type indicator.
[define -2- [v2 0f 0f]]

; The game.
[define game nil]

; Get data from an event.
[define dataOf fst]

; Get subscriber from an event.
[define subscriberOf snd]

; Get publisher from an event.
[define publisherOf thd]

; Get address from an event.
[define addressOf fth]