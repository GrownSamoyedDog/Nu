// Nu Game Engine.
// Copyright (C) Bryan Edds, 2012-2017.

(* The bool type indicator.      *) [define -b- false]
(* The int type indicator.       *) [define -i- 0]
(* The int64 type indicator.     *) [define -L- 0L]
(* The single type indicator.    *) [define -f- 0f]
(* The double type indicator.    *) [define -d- 0d]
(* The v2 type indicator.        *) [define -2- [v2 0f 0f]]
(* The string type indicator.    *) [define -s- ""]
(* The keyword type indicator.   *) [define -k- nil]
(* The tuple type indicator.     *) [define -u- [tuple]]
(* The keyphrase type indicator. *) [define -p- [nil]]
(* The option type indicator.    *) [define -o- none]
(* The list type indicator.      *) [define -l- [list]]
(* The ring type indicator.      *) [define -r- [ring]]
(* The table type indicator.     *) [define -t- [table]]
(* The unit type indicator.      *) [define -u- []]

// The identity function.
[define id [a] a]

// Flip a binary function's arguments.
[define flip [f]
 [fun [a b] [f b a]]]

// Check that a value is the identity.
[define isIdentity [a]
 [= a [toIdentity a]]]

// Check that a value is positive.
[define isPositive [a]
 [>= a [toEmpty a]]]

// Check that a value is negative.
[define isNegative [a]
 [<= a [toEmpty a]]]

// Check that a value is positive infinity.
[define isPositiveInf [a]
 [> a [toMax a]]]

// Check that a value is negative infinity.
[define isNegativeInf [a]
 [< a [toMin a]]]

// Check that a value is NaN.
[define isNaN [a]
 [|| [isPositiveInf a]
     [isNegativeInf a]]]

// Select the mininum value.
[define min [a b]
 [if [< a b] a b]]

// Select the maximum value.
[define max [a b]
 [if [> a b] a b]]

// Compare two values. Returns Lt, Gt, or Eq.
[define compare [a b]
 [if [< a b] Lt [if [> a b] Gt Eq]]]

// The sign of a value. Returns Positive, Negative, or Zero.
[define sign [a]
 [if [> a [toEmpty a]] Positive [if [< [toEmpty a]] Negative Zero]]]

// Compute the absolute value.
[define abs [a]
 [if [isPositive a] a [negate a]]]

// Mathematical constant pi as a single value.
[define pi 3.14159f]

// Mathematical constant e as a single value.
[define e 2.71828f]

// The zero v2 value.
[define v2Zero [toEmpty -2-]]

// The identity / unit v2 value.
[define v2Identity [toIdentity -2-]]

[define takeWhile [pred ctr]
    [let [takeWhileInner [pred ctr]
            [let [opt [trySplit ctr]]]
                [if [&& [isSome opt] [pred [fst opt]]]
                    [cons [fst opt] [takeWhile pred [snd opt]]]
                    [toEmpty ctr]]]]
         [christen [takeWhileInner pred ctr]]]

[define take [count ctr]
    [let [takeInner [current count ctr]
            [let [opt [trySplit ctr]]]
                 [if [&& [isSome opt] [< current count]]
                     [cons [fst opt] [takeInner [inc current] count [snd opt]]]
                     [toEmpty ctr]]]]]
         [christen [takeInner 0 count ctr]]]]

(*
TODO: exists in terms of map and contains

TODO: reduceWhile in terms of foldWhile

TODO: reduce in terms of fold

[def sliceWhen [pred seq] where: [[fun pred] [sequence seq]]
    doc: "Slice elements of a sequence in two parts, slicing at the first element that satisfies the predicate."
    (if (isDone seq)
        (pair (list) (list))
        (let (value (peek seq))
             (if (pred value)
                 (pair (list) (sequenceToList seq))
                 (let (nextSeq (next seq))
                      (nextResult (sliceWhen pred nextSeq))
                      (pair (cons value nextResult.first)
                            nextResult.second)))))]
    
[def slice [count seq] where: [[int count] [sequence seq]]
    doc: "Slice elements of a sequence in two parts, staring at the count'th element."
    pre: (isPositive count)
    (if (or (isZero count) (isDone seq))
        (pair (list) (sequenceToList seq))
        (let (value (peek seq))
             (nextSeq (next seq))
             (nextCount (dec count))
             (nextResult (slice nextCount nextSeq))
             (pair (cons value nextResult.first)
                   nextResult.second)))]
    
[def zipWith [zipper seq seq2] where: [[fun zipper] [sequence seq] [sequence seq2]]
    doc: "Zip two sequences with a given function."
    (if (or (isDone seq) (isDone seq2))
        (list)
        (let (value (peek seq))
             (value2 (peek seq2))
             (nextSeq (next seq))
             (nextSeq2 (next seq2))
             (cons (zipper value value2)
                   (zipWith zipper nextSeq nextSeq2))))]
    
[def zip [seq seq2] where: [[sequence seq] [sequence seq2]]
    doc: "Zip two sequences into a sequence of pairs."
    (zipWith
        (fun (first second) (pair first second))
        seq
        seq2)]
    
[def unzip [seq] where: [[sequence seq]]
    doc: "Unzip a sequence of pairs into a pair of sequences."
    (let
        (prRev
            (fold
                (fun (state current)
                    (pair (cons current.first state.first)
                          (cons current.second state.second)))
                (pair (list) (list))
                seq))
        (pair (reverse prRev.first) (reverse prRev.second)))]
    
[def partition [pred seq] where: [[fun pred] [sequence seq]]
    doc: "Parition a sequence into a pair of sequences."
    (if (isDone seq)
        (pair (list) (list))
        (let (value (peek seq))
             (nextSeq (next seq))
             (nextResult (partition pred nextSeq))
             (nextResultFirst nextResult.first)
             (nextResultSecond nextResult.second)
             (if (pred value)
                 (pair (cons value nextResultFirst) nextResultSecond)
                 (pair nextResultFirst (cons value nextResultSecond)))))]
*)