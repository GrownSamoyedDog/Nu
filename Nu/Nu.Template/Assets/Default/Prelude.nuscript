// Nu Game Engine.
// Copyright (C) Bryan Edds, 2012-2017.

(* The bool type indicator.      *) [define -b- false]
(* The int type indicator.       *) [define -i- 0]
(* The int64 type indicator.     *) [define -L- 0L]
(* The single type indicator.    *) [define -f- 0f]
(* The double type indicator.    *) [define -d- 0d]
(* The v2 type indicator.        *) [define -2- [v2 0f 0f]]
(* The string type indicator.    *) [define -s- ""]
(* The keyword type indicator.   *) [define -k- nil]
(* The tuple type indicator.     *) [define -u- [tuple]]
(* The keyphrase type indicator. *) [define -p- [nil]]
(* The option type indicator.    *) [define -o- none]
(* The list type indicator.      *) [define -l- [list]]
(* The ring type indicator.      *) [define -r- [ring]]
(* The table type indicator.     *) [define -t- [table]]
(* The unit type indicator.      *) [define -u- []]

// The identity function.
[define id [a] a]

// Flip a binary function's arguments.
[define flip [f]
 [fun [a b] [f b a]]]

// Check that a value is the identity.
[define isIdentity [a]
 [= a [toIdentity a]]]

// Check that a value is positive.
[define isPositive [a]
 [>= a [toEmpty a]]]

// Check that a value is negative.
[define isNegative [a]
 [<= a [toEmpty a]]]

// Check that a value is positive infinity.
[define isPositiveInf [a]
 [> a [toMax a]]]

// Check that a value is negative infinity.
[define isNegativeInf [a]
 [< a [toMin a]]]

// Check that a value is NaN.
[define isNaN [a]
 [|| [isPositiveInf a]
     [isNegativeInf a]]]

// Select the mininum value.
[define min [a b]
 [if [< a b] a b]]

// Select the maximum value.
[define max [a b]
 [if [> a b] a b]]

// Compare two values. Returns Lt, Gt, or Eq.
[define compare [a b]
 [if [< a b] Lt [if [> a b] Gt Eq]]]

// The sign of a value. Returns Positive, Negative, or Zero.
[define sign [a]
 [if [> a [toEmpty a]] Positive [if [< [toEmpty a]] Negative Zero]]]

// Compute the absolute value.
[define abs [a]
 [if [isPositive a] a [negate a]]]

// Dereference a structure, then get its first item.
[define fst! a
    [fst [! a]]]

// Dereference a structure, then get its second item.
[define snd! [a]
    [snd [! a]]]

// Mathematical constant pi as a single value.
[define pi 3.14159f]

// Mathematical constant e as a single value.
[define e 2.71828f]

// The zero v2 value.
[define v2Zero [toEmpty -2-]]

// The identity / unit v2 value.
[define v2Identity [toIdentity -2-]]

[define takeWhile [pred ctr]
    [let [takeWhileInner [pred ctr]
            [let [prOpt [tryUncons ctr]]
                 [if [&& [isSome prOpt] [pred [fst! prOpt]]]
                     [cons [fst! prOpt] [takeWhileInner pred [snd! prOpt]]]
                     [toEmpty ctr]]]]
         [commit [takeWhileInner pred ctr]]]]

[define take [count ctr]
    [let [takeInner [current count ctr]]
            [let [prOpt [tryUncons ctr]]
                 [if [&& [isSome prOpt] [< current count]]
                     [cons [fst! prOpt] [takeInner [inc current] count [snd! prOpt]]]
                     [toEmpty ctr]]]
         [commit [takeInner 0 count ctr]]]]

[define skipWhile [pred ctr]
    [let [skipWhileInner [pred ctr]
            [let [prOpt [tryUncons ctr]]
                 [if [&& [isSome prOpt] [pred [fst! prOpt]]]
                     [skipWhileInner pred [snd! prOpt]]
                     ctr]]]
         [commit [skipWhileInner pred ctr]]]]

[define skip [count ctr]
    [let [skipInner [current count ctr]]
            [let [prOpt [tryUncons ctr]]
                 [if [&& [isSome prOpt] [< current count]]
                     [cons [fst! prOpt] [skipInner [inc current] count [snd! prOpt]]]
                     ctr]]
         [commit [skipInner 0 count ctr]]]]

[define reduceWhile [reducer ctr]
    [let [pr [split ctr]]
         [foldWhile reducer [fst pr] [snd pr]]]]

[define reduce [reducer ctr]
    [let [pr [split ctr]]
         [fold reducer [fst pr] [snd pr]]]

[define tryItem [index ctr]
    [map fst [tryUncons [skip index ctr]]]]

[define exists [by ctr]
    [let [prOpt [tryUncons ctr]]
         [if [isSome prOpt]
             [if [by [fst! prOpt]]
                 true
                 [exists by [snd! prOpt]]]
             false]]]

[define count [by ctr]
    [let [countInner [count by ctr]]
         [let [prOpt [tryUncons ctr]]
              [if [isSome prOpt]
                  [if [by [fst! prOpt]]
                      count
                      [countInner [inc count] by [snd! prOpt]]]
                  false]]
         [countInner 0 by ctr]]]

(*
TODO: fstAs - nthAs, itemAs, sort, replace, slice (subsequence), chop

TODO [def zip [seq seq2] where: [[sequence seq] [sequence seq2]]
    doc: "Zip two sequences into a sequence of pairs."
    (zipWith
        (fun (first second) (pair first second))
        seq
        seq2)]
    
TODO [def unzip [seq] where: [[sequence seq]]
    doc: "Unzip a sequence of pairs into a pair of sequences."
    (let
        (prRev
            (fold
                (fun (state current)
                    (pair (cons current.first state.first)
                          (cons current.second state.second)))
                (pair (list) (list))
                seq))
        (pair (reverse prRev.first) (reverse prRev.second)))]
*)