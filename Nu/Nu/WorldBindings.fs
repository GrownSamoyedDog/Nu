// Nu Game Engine.
// Copyright (C) Bryan Edds, 2013-2018.

//*********************************************************************************************//
//                                                                                             //
// NOTE: This code is GENERATED by 'GenerateWorldBindings.fsx'! Do NOT edit this code by hand! //
//                                                                                             //
//*********************************************************************************************//

namespace Nu
open System
open OpenTK
open Prime
open global.Nu

[<RequireQualifiedAccess>]
module WorldBindings =

    let [<Literal>] BindingKeywords =
        "resolve tryGetIsSelectedScreenIdling tryGetIsSelectedScreenTransitioning isSelectedScreenIdling isSelectedScreenTransitioning " +
        "selectScreen tryTransitionScreen transitionScreen createDissolveScreenFromLayerFile6 createDissolveScreenFromLayerFile " +
        "createSplashScreen6 createSplashScreen getEntitiesInView2 getEntitiesInBounds3 " +
        "getEntitiesAtPoint3 getEntitiesInView getEntitiesInBounds getEntitiesAtPoint " +
        "playSong playSong4 playSound playSound3 " +
        "fadeOutSong stopSong hintAudioPackageUse hintAudioPackageDisuse " +
        "reloadAudioAssets hintRenderPackageUse hintRenderPackageDisuse reloadRenderAssets " +
        "bodyExists getBodyContactNormals getBodyLinearVelocity getBodyToGroundContactNormals " +
        "getBodyToGroundContactNormalOpt getBodyToGroundContactTangentOpt isBodyOnGround createBody " +
        "createBodies destroyBody destroyBodies setBodyPosition " +
        "setBodyRotation setBodyAngularVelocity setBodyLinearVelocity applyBodyAngularImpulse " +
        "applyBodyLinearImpulse applyBodyForce isMouseButtonDown getMousePosition " +
        "getMousePositionF isKeyboardKeyDown getSimulantSelected tryGetSimulantParent " +
        "getSimulantChildren getSimulantExists getEntities0 getLayers0 " +
        "isSimulantSelected writeGameToFile readGameFromFile getScreens " +
        "destroyScreen createScreen createDissolveScreen writeScreenToFile " +
        "readScreenFromFile getLayers destroyLayer destroyLayers " +
        "writeLayerToFile readLayerFromFile getEntities destroyEntity " +
        "destroyEntities tryPickEntity createEntity reassignEntity " +
        "trySetEntityOverlayNameOpt trySetEntityFacetNames createLayer getEyeCenter " +
        "setEyeCenter getEyeSize setEyeSize getOmniscreenOpt " +
        "setOmniscreenOpt getOmniscreen setOmniscreen getSelectedScreenOpt " +
        "setSelectedScreenOpt getSelectedScreen setSelectedScreen getScreenTransitionDestinationOpt " +
        "getViewBoundsRelative getViewBoundsAbsolute getViewBounds isBoundsInView " +
        "mouseToScreen mouseToWorld mouseToEntity getTickRate " +
        "getTickRateF setTickRate resetTickTime getTickTime " +
        "isTicking getUpdateCount getLiveness exit " +
        "tryGetTextureSize getTextureSize tryGetTextureSizeAsVector2 getTextureSizeAsVector2"

    let resolve relation world =
        let oldWorld = world
        try
            let relation =
                match ScriptingWorld.tryExport typeof<Relation<Object>> relation world with
                | Some value -> value :?> Relation<Object>
                | None -> failwith "Invalid argument type for 'relation'; expecting a value convertable to Relation`1."
            let result = World.resolveGeneric relation world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Address<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resolve' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenIdling world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenTransitioning world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenIdling world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenTransitioning world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let selectScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.selectScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'selectScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryTransitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryTransitionScreen destination world
            let (value, world) = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryTransitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let transitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.transitionScreen destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'transitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromLayerFile6 dispatcherName nameOpt dissolveData layerFilePath world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingWorld.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveData =
                match ScriptingWorld.tryExport typeof<DissolveData> dissolveData world with
                | Some value -> value :?> DissolveData
                | None -> failwith "Invalid argument type for 'dissolveData'; expecting a value convertable to DissolveData."
            let layerFilePath =
                match ScriptingWorld.tryExport typeof<String> layerFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'layerFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromLayerFile6 dispatcherName nameOpt dissolveData layerFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromLayerFile6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromLayerFile nameOpt dissolveData layerFilePath world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveData =
                match ScriptingWorld.tryExport typeof<DissolveData> dissolveData world with
                | Some value -> value :?> DissolveData
                | None -> failwith "Invalid argument type for 'dissolveData'; expecting a value convertable to DissolveData."
            let layerFilePath =
                match ScriptingWorld.tryExport typeof<String> layerFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'layerFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromLayerFile nameOpt dissolveData layerFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromLayerFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen6 dispatcherName nameOpt splashData destination world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingWorld.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashData =
                match ScriptingWorld.tryExport typeof<SplashData> splashData world with
                | Some value -> value :?> SplashData
                | None -> failwith "Invalid argument type for 'splashData'; expecting a value convertable to SplashData."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen6 dispatcherName nameOpt splashData destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen nameOpt splashData destination world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashData =
                match ScriptingWorld.tryExport typeof<SplashData> splashData world with
                | Some value -> value :?> SplashData
                | None -> failwith "Invalid argument type for 'splashData'; expecting a value convertable to SplashData."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen nameOpt splashData destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInView2 screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesInView2 screen world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInView2' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInBounds3 bounds screen world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingWorld.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesInBounds3 bounds screen world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInBounds3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesAtPoint3 point screen world =
        let oldWorld = world
        try
            let point =
                match ScriptingWorld.tryExport typeof<Vector2> point world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'point'; expecting a value convertable to Vector2."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesAtPoint3 point screen world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesAtPoint3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInView world =
        let oldWorld = world
        try
            let result = World.getEntitiesInView world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInView' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInBounds bounds world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingWorld.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let result = World.getEntitiesInBounds bounds world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesAtPoint point world =
        let oldWorld = world
        try
            let point =
                match ScriptingWorld.tryExport typeof<Vector2> point world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'point'; expecting a value convertable to Vector2."
            let result = World.getEntitiesAtPoint point world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesAtPoint' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong timeToFadeOutSongMs volume song world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingWorld.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingWorld.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let song =
                match ScriptingWorld.tryExport typeof<AssetTag<Audio>> song world with
                | Some value -> value :?> AssetTag<Audio>
                | None -> failwith "Invalid argument type for 'song'; expecting a value convertable to AssetTag`1."
            let result = World.playSong timeToFadeOutSongMs volume song world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong4 timeToFadeOutSongMs volume songPackageName songAssetName world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingWorld.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingWorld.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let songPackageName =
                match ScriptingWorld.tryExport typeof<String> songPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songPackageName'; expecting a value convertable to String."
            let songAssetName =
                match ScriptingWorld.tryExport typeof<String> songAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songAssetName'; expecting a value convertable to String."
            let result = World.playSong5 timeToFadeOutSongMs volume songPackageName songAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong4' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound volume sound world =
        let oldWorld = world
        try
            let volume =
                match ScriptingWorld.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let sound =
                match ScriptingWorld.tryExport typeof<AssetTag<Audio>> sound world with
                | Some value -> value :?> AssetTag<Audio>
                | None -> failwith "Invalid argument type for 'sound'; expecting a value convertable to AssetTag`1."
            let result = World.playSound volume sound world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound3 volume soundPackageName soundAssetName world =
        let oldWorld = world
        try
            let volume =
                match ScriptingWorld.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let soundPackageName =
                match ScriptingWorld.tryExport typeof<String> soundPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundPackageName'; expecting a value convertable to String."
            let soundAssetName =
                match ScriptingWorld.tryExport typeof<String> soundAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundAssetName'; expecting a value convertable to String."
            let result = World.playSound4 volume soundPackageName soundAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let fadeOutSong timeToFadeOutSongMs world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingWorld.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let result = World.fadeOutSong timeToFadeOutSongMs world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'fadeOutSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let stopSong world =
        let oldWorld = world
        try
            let result = World.stopSong world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'stopSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingWorld.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingWorld.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadAudioAssets world =
        let oldWorld = world
        try
            let result = World.reloadAudioAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadAudioAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintRenderPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingWorld.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintRenderPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintRenderPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintRenderPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingWorld.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintRenderPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintRenderPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadRenderAssets world =
        let oldWorld = world
        try
            let result = World.reloadRenderAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadRenderAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let bodyExists physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.bodyExists physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'bodyExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyContactNormals physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyContactNormals physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpList<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyContactNormals' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyLinearVelocity physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyLinearVelocity physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyLinearVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormals physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactNormals physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpList<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormals' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormalOpt physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactNormalOpt physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormalOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactTangentOpt physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactTangentOpt physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactTangentOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isBodyOnGround physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.isBodyOnGround physicsId world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBodyOnGround' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createBody entity entityId bodyProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingWorld.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let bodyProperties =
                match ScriptingWorld.tryExport typeof<BodyProperties> bodyProperties world with
                | Some value -> value :?> BodyProperties
                | None -> failwith "Invalid argument type for 'bodyProperties'; expecting a value convertable to BodyProperties."
            let result = World.createBody entity entityId bodyProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBody' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createBodies entity entityId bodiesProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingWorld.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let struct (bodiesProperties, world) =
                match World.evalInternal bodiesProperties world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingWorld.tryExport typeof<BodyProperties> value world with
                            | Some value -> value :?> BodyProperties
                            | None -> failwith "Invalid argument type for 'bodiesProperties'; expecting a value convertable to BodyProperties."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createBodies entity entityId bodiesProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBodies' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyBody physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.destroyBody physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBody' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyBodies physicsIds world =
        let oldWorld = world
        try
            let struct (physicsIds, world) =
                match World.evalInternal physicsIds world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingWorld.tryExport typeof<PhysicsId> value world with
                            | Some value -> value :?> PhysicsId
                            | None -> failwith "Invalid argument type for 'physicsIds'; expecting a value convertable to PhysicsId."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyBodies physicsIds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBodies' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyPosition position physicsId world =
        let oldWorld = world
        try
            let position =
                match ScriptingWorld.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyPosition position physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyPosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyRotation rotation physicsId world =
        let oldWorld = world
        try
            let rotation =
                match ScriptingWorld.tryExport typeof<Single> rotation world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'rotation'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyRotation rotation physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyRotation' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyAngularVelocity angularVelocity physicsId world =
        let oldWorld = world
        try
            let angularVelocity =
                match ScriptingWorld.tryExport typeof<Single> angularVelocity world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'angularVelocity'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyAngularVelocity angularVelocity physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyAngularVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyLinearVelocity linearVelocity physicsId world =
        let oldWorld = world
        try
            let linearVelocity =
                match ScriptingWorld.tryExport typeof<Vector2> linearVelocity world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'linearVelocity'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyLinearVelocity linearVelocity physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyLinearVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyAngularImpulse angularImpulse physicsId world =
        let oldWorld = world
        try
            let angularImpulse =
                match ScriptingWorld.tryExport typeof<Single> angularImpulse world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'angularImpulse'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyAngularImpulse angularImpulse physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyAngularImpulse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyLinearImpulse linearImpulse physicsId world =
        let oldWorld = world
        try
            let linearImpulse =
                match ScriptingWorld.tryExport typeof<Vector2> linearImpulse world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'linearImpulse'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyLinearImpulse linearImpulse physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyLinearImpulse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyForce force physicsId world =
        let oldWorld = world
        try
            let force =
                match ScriptingWorld.tryExport typeof<Vector2> force world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'force'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingWorld.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyForce force physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyForce' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isMouseButtonDown mouseButton world =
        let oldWorld = world
        try
            let mouseButton =
                match ScriptingWorld.tryExport typeof<MouseButton> mouseButton world with
                | Some value -> value :?> MouseButton
                | None -> failwith "Invalid argument type for 'mouseButton'; expecting a value convertable to MouseButton."
            let result = World.isMouseButtonDown mouseButton world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isMouseButtonDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMousePosition world =
        let oldWorld = world
        try
            let result = World.getMousePosition world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMousePositionF world =
        let oldWorld = world
        try
            let result = World.getMousePositionF world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePositionF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isKeyboardKeyDown scanCode world =
        let oldWorld = world
        try
            let scanCode =
                match ScriptingWorld.tryExport typeof<Int32> scanCode world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'scanCode'; expecting a value convertable to Int32."
            let result = World.isKeyboardKeyDown scanCode world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardKeyDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSimulantSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.deriveSimulant address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getSimulantSelected simulant world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSimulantSelected' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetSimulantParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.deriveSimulant address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetSimulantParent simulant world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetSimulantParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSimulantChildren simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.deriveSimulant address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getSimulantChildren simulant world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSimulantChildren' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSimulantExists simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.deriveSimulant address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getSimulantExists simulant world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSimulantExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities0 world =
        let oldWorld = world
        try
            let result = World.getEntities1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLayers0 world =
        let oldWorld = world
        try
            let result = World.getLayers1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLayers0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSimulantSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.deriveSimulant address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.isSimulantSelected simulant world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSimulantSelected' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeGameToFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingWorld.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.writeGameToFile filePath world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGameToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readGameFromFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingWorld.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.readGameFromFile filePath world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGameFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getScreens world =
        let oldWorld = world
        try
            let result = World.getScreens world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreens' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createScreen dispatcherName nameOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingWorld.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createScreen3 dispatcherName nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreen dispatcherName nameOpt dissolveData world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingWorld.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveData =
                match ScriptingWorld.tryExport typeof<DissolveData> dissolveData world with
                | Some value -> value :?> DissolveData
                | None -> failwith "Invalid argument type for 'dissolveData'; expecting a value convertable to DissolveData."
            let result = World.createDissolveScreen5 dispatcherName nameOpt dissolveData world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeScreenToFile filePath screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingWorld.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeScreenToFile filePath screen world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeScreenToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readScreenFromFile filePath nameOpt world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingWorld.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.readScreenFromFile filePath nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readScreenFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLayers screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getLayers screen world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLayers' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyLayer layer world =
        let oldWorld = world
        try
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyLayer layer world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyLayer' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyLayers layers world =
        let oldWorld = world
        try
            let struct (layers, world) =
                let context = World.getScriptContext world
                match World.evalInternal layers world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Layer address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyLayers layers world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyLayers' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeLayerToFile filePath layer world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingWorld.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeLayerToFile filePath layer world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeLayerToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readLayerFromFile filePath nameOpt screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingWorld.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readLayerFromFile filePath nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readLayerFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities layer world =
        let oldWorld = world
        try
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntities layer world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntity entity world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyEntity entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntities entities world =
        let oldWorld = world
        try
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyEntities entities world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryPickEntity position entities world =
        let oldWorld = world
        try
            let position =
                match ScriptingWorld.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.tryPickEntity position entities world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Entity>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryPickEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createEntity dispatcherName nameOpt overlayNameDescriptor layer world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingWorld.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let overlayNameDescriptor =
                match ScriptingWorld.tryExport typeof<OverlayNameDescriptor> overlayNameDescriptor world with
                | Some value -> value :?> OverlayNameDescriptor
                | None -> failwith "Invalid argument type for 'overlayNameDescriptor'; expecting a value convertable to OverlayNameDescriptor."
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createEntity5 dispatcherName nameOpt overlayNameDescriptor layer world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reassignEntity entity nameOpt layer world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.reassignEntity entity nameOpt layer world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reassignEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityOverlayNameOpt overlayNameOpt entity world =
        let oldWorld = world
        try
            let overlayNameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> overlayNameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'overlayNameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityOverlayNameOptFromScript overlayNameOpt entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityOverlayNameOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityFacetNames facetNames entity world =
        let oldWorld = world
        try
            let facetNames =
                match ScriptingWorld.tryExport typeof<FSharpSet<String>> facetNames world with
                | Some value -> value :?> FSharpSet<String>
                | None -> failwith "Invalid argument type for 'facetNames'; expecting a value convertable to FSharpSet`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityFacetNamesFromScript facetNames entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityFacetNames' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createLayer dispatcherName nameOpt screen world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingWorld.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingWorld.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createLayer4 dispatcherName nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createLayer' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeCenter world =
        let oldWorld = world
        try
            let result = World.getEyeCenter world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeCenter' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setEyeCenter value world =
        let oldWorld = world
        try
            let value =
                match ScriptingWorld.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeCenter value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeCenter' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeSize world =
        let oldWorld = world
        try
            let result = World.getEyeSize world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setEyeSize value world =
        let oldWorld = world
        try
            let value =
                match ScriptingWorld.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeSize value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getOmniscreenOpt world =
        let oldWorld = world
        try
            let result = World.getOmniscreenOpt world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniscreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setOmniscreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingWorld.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setOmniscreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniscreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getOmniscreen world =
        let oldWorld = world
        try
            let result = World.getOmniscreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniscreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setOmniscreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setOmniscreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniscreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelectedScreenOpt world =
        let oldWorld = world
        try
            let result = World.getSelectedScreenOpt world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setSelectedScreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingWorld.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setSelectedScreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelectedScreen world =
        let oldWorld = world
        try
            let result = World.getSelectedScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setSelectedScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setSelectedScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getScreenTransitionDestinationOpt world =
        let oldWorld = world
        try
            let result = World.getScreenTransitionDestinationOpt world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreenTransitionDestinationOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBoundsRelative world =
        let oldWorld = world
        try
            let result = World.getViewBoundsRelative world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBoundsRelative' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBoundsAbsolute world =
        let oldWorld = world
        try
            let result = World.getViewBoundsAbsolute world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBoundsAbsolute' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBounds viewType world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingWorld.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let result = World.getViewBounds viewType world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isBoundsInView viewType bounds world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingWorld.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let bounds =
                match ScriptingWorld.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let result = World.isBoundsInView viewType bounds world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBoundsInView' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToScreen mousePosition world =
        let oldWorld = world
        try
            let mousePosition =
                match ScriptingWorld.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToScreen mousePosition world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToWorld viewType mousePosition world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingWorld.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let mousePosition =
                match ScriptingWorld.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToWorld viewType mousePosition world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToWorld' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToEntity viewType entityPosition mousePosition world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingWorld.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let entityPosition =
                match ScriptingWorld.tryExport typeof<Vector2> entityPosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'entityPosition'; expecting a value convertable to Vector2."
            let mousePosition =
                match ScriptingWorld.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToEntity viewType entityPosition mousePosition world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickRate world =
        let oldWorld = world
        try
            let result = World.getTickRate world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickRateF world =
        let oldWorld = world
        try
            let result = World.getTickRateF world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickRateF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setTickRate tickRate world =
        let oldWorld = world
        try
            let tickRate =
                match ScriptingWorld.tryExport typeof<Int64> tickRate world with
                | Some value -> value :?> Int64
                | None -> failwith "Invalid argument type for 'tickRate'; expecting a value convertable to Int64."
            let result = World.setTickRate tickRate world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setTickRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let resetTickTime world =
        let oldWorld = world
        try
            let result = World.resetTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resetTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickTime world =
        let oldWorld = world
        try
            let result = World.getTickTime world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isTicking world =
        let oldWorld = world
        try
            let result = World.isTicking world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isTicking' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getUpdateCount world =
        let oldWorld = world
        try
            let result = World.getUpdateCount world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getUpdateCount' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLiveness world =
        let oldWorld = world
        try
            let result = World.getLiveness world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Liveness> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLiveness' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let exit world =
        let oldWorld = world
        try
            let result = World.exit world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'exit' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingWorld.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSize assetTag world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Vector2i>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingWorld.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSize assetTag world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSizeAsVector2 assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingWorld.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSizeAsVector2 assetTag world
            let value = result
            let value = ScriptingWorld.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSizeAsVector2' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSizeAsVector2 assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingWorld.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSizeAsVector2 assetTag world
            let value = result
            let value = ScriptingWorld.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSizeAsVector2' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let evalResolveBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|relation|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            resolve relation world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryGetIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryGetIsSelectedScreenIdling  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryGetIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryGetIsSelectedScreenTransitioning  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isSelectedScreenIdling  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isSelectedScreenTransitioning  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSelectScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            selectScreen screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryTransitionScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|destination|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryTransitionScreen destination world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTransitionScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|destination|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            transitionScreen destination world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateDissolveScreenFromLayerFile6Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|dispatcherName; nameOpt; dissolveData; layerFilePath|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createDissolveScreenFromLayerFile6 dispatcherName nameOpt dissolveData layerFilePath world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateDissolveScreenFromLayerFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|nameOpt; dissolveData; layerFilePath|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createDissolveScreenFromLayerFile nameOpt dissolveData layerFilePath world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateSplashScreen6Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|dispatcherName; nameOpt; splashData; destination|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createSplashScreen6 dispatcherName nameOpt splashData destination world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateSplashScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|nameOpt; splashData; destination|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createSplashScreen nameOpt splashData destination world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesInView2Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntitiesInView2 screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesInBounds3Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|bounds; screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntitiesInBounds3 bounds screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesAtPoint3Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|point; screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntitiesAtPoint3 point screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesInViewBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntitiesInView  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesInBoundsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|bounds|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntitiesInBounds bounds world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesAtPointBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|point|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntitiesAtPoint point world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalPlaySongBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|timeToFadeOutSongMs; volume; song|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            playSong timeToFadeOutSongMs volume song world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalPlaySong4Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|timeToFadeOutSongMs; volume; songPackageName; songAssetName|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            playSong4 timeToFadeOutSongMs volume songPackageName songAssetName world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalPlaySoundBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|volume; sound|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            playSound volume sound world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalPlaySound3Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|volume; soundPackageName; soundAssetName|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            playSound3 volume soundPackageName soundAssetName world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalFadeOutSongBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|timeToFadeOutSongMs|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            fadeOutSong timeToFadeOutSongMs world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalStopSongBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            stopSong  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalHintAudioPackageUseBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|packageName|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            hintAudioPackageUse packageName world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalHintAudioPackageDisuseBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|packageName|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            hintAudioPackageDisuse packageName world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalReloadAudioAssetsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            reloadAudioAssets  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalHintRenderPackageUseBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|packageName|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            hintRenderPackageUse packageName world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalHintRenderPackageDisuseBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|packageName|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            hintRenderPackageDisuse packageName world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalReloadRenderAssetsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            reloadRenderAssets  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalBodyExistsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            bodyExists physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetBodyContactNormalsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getBodyContactNormals physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetBodyLinearVelocityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getBodyLinearVelocity physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetBodyToGroundContactNormalsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getBodyToGroundContactNormals physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetBodyToGroundContactNormalOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getBodyToGroundContactNormalOpt physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetBodyToGroundContactTangentOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getBodyToGroundContactTangentOpt physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsBodyOnGroundBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isBodyOnGround physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateBodyBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|entity; entityId; bodyProperties|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createBody entity entityId bodyProperties world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateBodiesBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|entity; entityId; bodiesProperties|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createBodies entity entityId bodiesProperties world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyBodyBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyBody physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyBodiesBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|physicsIds|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyBodies physicsIds world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetBodyPositionBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|position; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setBodyPosition position physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetBodyRotationBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|rotation; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setBodyRotation rotation physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetBodyAngularVelocityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|angularVelocity; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setBodyAngularVelocity angularVelocity physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetBodyLinearVelocityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|linearVelocity; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setBodyLinearVelocity linearVelocity physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalApplyBodyAngularImpulseBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|angularImpulse; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            applyBodyAngularImpulse angularImpulse physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalApplyBodyLinearImpulseBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|linearImpulse; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            applyBodyLinearImpulse linearImpulse physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalApplyBodyForceBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|force; physicsId|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            applyBodyForce force physicsId world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsMouseButtonDownBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|mouseButton|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isMouseButtonDown mouseButton world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetMousePositionBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getMousePosition  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetMousePositionFBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getMousePositionF  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsKeyboardKeyDownBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|scanCode|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isKeyboardKeyDown scanCode world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetSimulantSelectedBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|simulant|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getSimulantSelected simulant world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryGetSimulantParentBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|simulant|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryGetSimulantParent simulant world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetSimulantChildrenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|simulant|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getSimulantChildren simulant world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetSimulantExistsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|simulant|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getSimulantExists simulant world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntities0Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntities0  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetLayers0Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getLayers0  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsSimulantSelectedBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|simulant|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isSimulantSelected simulant world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalWriteGameToFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|filePath|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            writeGameToFile filePath world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalReadGameFromFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|filePath|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            readGameFromFile filePath world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetScreensBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getScreens  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyScreen screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|dispatcherName; nameOpt|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createScreen dispatcherName nameOpt world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateDissolveScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|dispatcherName; nameOpt; dissolveData|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createDissolveScreen dispatcherName nameOpt dissolveData world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalWriteScreenToFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|filePath; screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            writeScreenToFile filePath screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalReadScreenFromFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|filePath; nameOpt|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            readScreenFromFile filePath nameOpt world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetLayersBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getLayers screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyLayerBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|layer|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyLayer layer world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyLayersBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|layers|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyLayers layers world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalWriteLayerToFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|filePath; layer|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            writeLayerToFile filePath layer world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalReadLayerFromFileBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|filePath; nameOpt; screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            readLayerFromFile filePath nameOpt screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEntitiesBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|layer|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEntities layer world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyEntityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|entity|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyEntity entity world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalDestroyEntitiesBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|entities|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            destroyEntities entities world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryPickEntityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|position; entities|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryPickEntity position entities world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateEntityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|dispatcherName; nameOpt; overlayNameDescriptor; layer|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createEntity dispatcherName nameOpt overlayNameDescriptor layer world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalReassignEntityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|entity; nameOpt; layer|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            reassignEntity entity nameOpt layer world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTrySetEntityOverlayNameOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|overlayNameOpt; entity|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            trySetEntityOverlayNameOpt overlayNameOpt entity world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTrySetEntityFacetNamesBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|facetNames; entity|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            trySetEntityFacetNames facetNames entity world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalCreateLayerBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|dispatcherName; nameOpt; screen|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            createLayer dispatcherName nameOpt screen world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEyeCenterBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEyeCenter  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetEyeCenterBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|value|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setEyeCenter value world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetEyeSizeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getEyeSize  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetEyeSizeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|value|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setEyeSize value world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetOmniscreenOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getOmniscreenOpt  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetOmniscreenOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|value|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setOmniscreenOpt value world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetOmniscreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getOmniscreen  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetOmniscreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|value|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setOmniscreen value world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetSelectedScreenOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getSelectedScreenOpt  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetSelectedScreenOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|value|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setSelectedScreenOpt value world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetSelectedScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getSelectedScreen  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetSelectedScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|value|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setSelectedScreen value world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetScreenTransitionDestinationOptBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getScreenTransitionDestinationOpt  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetViewBoundsRelativeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getViewBoundsRelative  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetViewBoundsAbsoluteBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getViewBoundsAbsolute  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetViewBoundsBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|viewType|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getViewBounds viewType world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsBoundsInViewBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|viewType; bounds|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isBoundsInView viewType bounds world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalMouseToScreenBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|mousePosition|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            mouseToScreen mousePosition world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalMouseToWorldBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|viewType; mousePosition|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            mouseToWorld viewType mousePosition world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalMouseToEntityBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|viewType; entityPosition; mousePosition|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            mouseToEntity viewType entityPosition mousePosition world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetTickRateBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getTickRate  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetTickRateFBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getTickRateF  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalSetTickRateBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|tickRate|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            setTickRate tickRate world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalResetTickTimeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            resetTickTime  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetTickTimeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getTickTime  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalIsTickingBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            isTicking  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetUpdateCountBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getUpdateCount  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetLivenessBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getLiveness  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalExitBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([||] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            exit  world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryGetTextureSizeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|assetTag|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryGetTextureSize assetTag world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetTextureSizeBinding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|assetTag|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getTextureSize assetTag world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalTryGetTextureSizeAsVector2Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|assetTag|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            tryGetTextureSizeAsVector2 assetTag world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let evalGetTextureSizeAsVector2Binding fnName exprs originOpt world =
        match World.evalManyInternal exprs world with
        | struct ([|assetTag|] as args, world) when Array.notExists (function Scripting.Violation _ -> true | _ -> false) args ->
            getTextureSizeAsVector2 assetTag world
        | _ ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
            struct (violation, world)

    let tryGetBinding fnName =
        match WorldScripting.Bindings.TryGetValue fnName with
        | (true, binding) -> FOption.some binding
        | (false, _) -> FOption.none ()

    let initBindings () =
        let bindings =
            [
             ("resolve", evalResolveBinding)
             ("tryGetIsSelectedScreenIdling", evalTryGetIsSelectedScreenIdlingBinding)
             ("tryGetIsSelectedScreenTransitioning", evalTryGetIsSelectedScreenTransitioningBinding)
             ("isSelectedScreenIdling", evalIsSelectedScreenIdlingBinding)
             ("isSelectedScreenTransitioning", evalIsSelectedScreenTransitioningBinding)
             ("selectScreen", evalSelectScreenBinding)
             ("tryTransitionScreen", evalTryTransitionScreenBinding)
             ("transitionScreen", evalTransitionScreenBinding)
             ("createDissolveScreenFromLayerFile6", evalCreateDissolveScreenFromLayerFile6Binding)
             ("createDissolveScreenFromLayerFile", evalCreateDissolveScreenFromLayerFileBinding)
             ("createSplashScreen6", evalCreateSplashScreen6Binding)
             ("createSplashScreen", evalCreateSplashScreenBinding)
             ("getEntitiesInView2", evalGetEntitiesInView2Binding)
             ("getEntitiesInBounds3", evalGetEntitiesInBounds3Binding)
             ("getEntitiesAtPoint3", evalGetEntitiesAtPoint3Binding)
             ("getEntitiesInView", evalGetEntitiesInViewBinding)
             ("getEntitiesInBounds", evalGetEntitiesInBoundsBinding)
             ("getEntitiesAtPoint", evalGetEntitiesAtPointBinding)
             ("playSong", evalPlaySongBinding)
             ("playSong4", evalPlaySong4Binding)
             ("playSound", evalPlaySoundBinding)
             ("playSound3", evalPlaySound3Binding)
             ("fadeOutSong", evalFadeOutSongBinding)
             ("stopSong", evalStopSongBinding)
             ("hintAudioPackageUse", evalHintAudioPackageUseBinding)
             ("hintAudioPackageDisuse", evalHintAudioPackageDisuseBinding)
             ("reloadAudioAssets", evalReloadAudioAssetsBinding)
             ("hintRenderPackageUse", evalHintRenderPackageUseBinding)
             ("hintRenderPackageDisuse", evalHintRenderPackageDisuseBinding)
             ("reloadRenderAssets", evalReloadRenderAssetsBinding)
             ("bodyExists", evalBodyExistsBinding)
             ("getBodyContactNormals", evalGetBodyContactNormalsBinding)
             ("getBodyLinearVelocity", evalGetBodyLinearVelocityBinding)
             ("getBodyToGroundContactNormals", evalGetBodyToGroundContactNormalsBinding)
             ("getBodyToGroundContactNormalOpt", evalGetBodyToGroundContactNormalOptBinding)
             ("getBodyToGroundContactTangentOpt", evalGetBodyToGroundContactTangentOptBinding)
             ("isBodyOnGround", evalIsBodyOnGroundBinding)
             ("createBody", evalCreateBodyBinding)
             ("createBodies", evalCreateBodiesBinding)
             ("destroyBody", evalDestroyBodyBinding)
             ("destroyBodies", evalDestroyBodiesBinding)
             ("setBodyPosition", evalSetBodyPositionBinding)
             ("setBodyRotation", evalSetBodyRotationBinding)
             ("setBodyAngularVelocity", evalSetBodyAngularVelocityBinding)
             ("setBodyLinearVelocity", evalSetBodyLinearVelocityBinding)
             ("applyBodyAngularImpulse", evalApplyBodyAngularImpulseBinding)
             ("applyBodyLinearImpulse", evalApplyBodyLinearImpulseBinding)
             ("applyBodyForce", evalApplyBodyForceBinding)
             ("isMouseButtonDown", evalIsMouseButtonDownBinding)
             ("getMousePosition", evalGetMousePositionBinding)
             ("getMousePositionF", evalGetMousePositionFBinding)
             ("isKeyboardKeyDown", evalIsKeyboardKeyDownBinding)
             ("getSimulantSelected", evalGetSimulantSelectedBinding)
             ("tryGetSimulantParent", evalTryGetSimulantParentBinding)
             ("getSimulantChildren", evalGetSimulantChildrenBinding)
             ("getSimulantExists", evalGetSimulantExistsBinding)
             ("getEntities0", evalGetEntities0Binding)
             ("getLayers0", evalGetLayers0Binding)
             ("isSimulantSelected", evalIsSimulantSelectedBinding)
             ("writeGameToFile", evalWriteGameToFileBinding)
             ("readGameFromFile", evalReadGameFromFileBinding)
             ("getScreens", evalGetScreensBinding)
             ("destroyScreen", evalDestroyScreenBinding)
             ("createScreen", evalCreateScreenBinding)
             ("createDissolveScreen", evalCreateDissolveScreenBinding)
             ("writeScreenToFile", evalWriteScreenToFileBinding)
             ("readScreenFromFile", evalReadScreenFromFileBinding)
             ("getLayers", evalGetLayersBinding)
             ("destroyLayer", evalDestroyLayerBinding)
             ("destroyLayers", evalDestroyLayersBinding)
             ("writeLayerToFile", evalWriteLayerToFileBinding)
             ("readLayerFromFile", evalReadLayerFromFileBinding)
             ("getEntities", evalGetEntitiesBinding)
             ("destroyEntity", evalDestroyEntityBinding)
             ("destroyEntities", evalDestroyEntitiesBinding)
             ("tryPickEntity", evalTryPickEntityBinding)
             ("createEntity", evalCreateEntityBinding)
             ("reassignEntity", evalReassignEntityBinding)
             ("trySetEntityOverlayNameOpt", evalTrySetEntityOverlayNameOptBinding)
             ("trySetEntityFacetNames", evalTrySetEntityFacetNamesBinding)
             ("createLayer", evalCreateLayerBinding)
             ("getEyeCenter", evalGetEyeCenterBinding)
             ("setEyeCenter", evalSetEyeCenterBinding)
             ("getEyeSize", evalGetEyeSizeBinding)
             ("setEyeSize", evalSetEyeSizeBinding)
             ("getOmniscreenOpt", evalGetOmniscreenOptBinding)
             ("setOmniscreenOpt", evalSetOmniscreenOptBinding)
             ("getOmniscreen", evalGetOmniscreenBinding)
             ("setOmniscreen", evalSetOmniscreenBinding)
             ("getSelectedScreenOpt", evalGetSelectedScreenOptBinding)
             ("setSelectedScreenOpt", evalSetSelectedScreenOptBinding)
             ("getSelectedScreen", evalGetSelectedScreenBinding)
             ("setSelectedScreen", evalSetSelectedScreenBinding)
             ("getScreenTransitionDestinationOpt", evalGetScreenTransitionDestinationOptBinding)
             ("getViewBoundsRelative", evalGetViewBoundsRelativeBinding)
             ("getViewBoundsAbsolute", evalGetViewBoundsAbsoluteBinding)
             ("getViewBounds", evalGetViewBoundsBinding)
             ("isBoundsInView", evalIsBoundsInViewBinding)
             ("mouseToScreen", evalMouseToScreenBinding)
             ("mouseToWorld", evalMouseToWorldBinding)
             ("mouseToEntity", evalMouseToEntityBinding)
             ("getTickRate", evalGetTickRateBinding)
             ("getTickRateF", evalGetTickRateFBinding)
             ("setTickRate", evalSetTickRateBinding)
             ("resetTickTime", evalResetTickTimeBinding)
             ("getTickTime", evalGetTickTimeBinding)
             ("isTicking", evalIsTickingBinding)
             ("getUpdateCount", evalGetUpdateCountBinding)
             ("getLiveness", evalGetLivenessBinding)
             ("exit", evalExitBinding)
             ("tryGetTextureSize", evalTryGetTextureSizeBinding)
             ("getTextureSize", evalGetTextureSizeBinding)
             ("tryGetTextureSizeAsVector2", evalTryGetTextureSizeAsVector2Binding)
             ("getTextureSizeAsVector2", evalGetTextureSizeAsVector2Binding)
            ] |>
            dictPlus
        WorldScripting.Bindings <- bindings
