<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Prime</name></assembly>
<members>
<member name="M:Array.tryFindIndexRev``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Try to find an index in reverse.
</summary>
</member>
<member name="M:List.hash``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Hash a list.
 NOTE: May be a pessimization.
</summary>
</member>
<member name="M:List.compareStrings(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Compare a list of strings lexicographically.
</summary>
</member>
<member name="M:List.duplicates``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Find the duplicates in a list.
 TODO: speed this up with a Set internally?
</summary>
</member>
<member name="M:List.collapseLeft``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Collapse a list from the left.
 Example - [0, 1, 2] becomes [[]; [0]; [0; 1]; [0; 1; 2]]
</summary>
</member>
<member name="M:List.remove``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Remove all elements from a list that satisfy a predicate.
</summary>
</member>
<member name="M:List.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:List.toHashSet``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list to a HashSet.
</summary>
</member>
<member name="M:List.toDictBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list of values to a Dictionary.
</summary>
</member>
<member name="M:List.toDict``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Convert a list of pairs to a Dictionary.
</summary>
</member>
<member name="M:List.addToDictBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},System.Collections.Generic.Dictionary{``1,``2},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Add a list of values to a Dictionary.
</summary>
</member>
<member name="M:List.addToDict``2(System.Collections.Generic.Dictionary{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Add a list of pairs to a Dictionary.
</summary>
</member>
<member name="M:List.intersect``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get the set interesection of two lists.
</summary>
</member>
<member name="M:List.isSuperset``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that the first list a superset of the second list.
</summary>
</member>
<member name="M:List.isSubset``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that the first list a subset of the second list.
</summary>
</member>
<member name="M:List.setBinop``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``1},``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Runs a binary set operation on two lists that are converted to sets.
</summary>
</member>
<member name="M:List.takeTillInclusive``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Take elements until an element satisfies a predicate, taking also that element.
</summary>
</member>
<member name="M:List.joinList``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Join a list of lists into a list separated by sep.
</summary>
</member>
<member name="M:List.joinBy``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.String},System.String,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Join a list into a string separated by sep.
 TODO: consider optimizing with a StringBuilder.
</summary>
</member>
<member name="M:List.join(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Join a list into a string separated by sep.
</summary>
</member>
<member name="M:List.padWithLastToProportion``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Pad a list with instances of its last item so that it is proportion to another list.
</summary>
</member>
<member name="M:List.padWithLast``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Pad a list with count instances of its last item.
</summary>
</member>
<member name="M:List.allOrEmptyBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Make a transformed list of options an all or nothing proposition.
 TODO: optimize with program fusion.
</summary>
</member>
<member name="M:List.allOrEmpty``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Make a list of options an all or nothing proposition.
 TODO: optimize with program fusion.
</summary>
</member>
<member name="M:List.definitize``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:List.allButLast``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get all but the last item from a list.
</summary>
</member>
<member name="M:List.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Foldi for lists.
</summary>
</member>
<member name="M:List.fornone``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Fornone for lists.
</summary>
</member>
<member name="M:List.replaceHead``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Replace a list&apos;s head.
</summary>
</member>
<member name="M:List.project``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Project the first list onto the second.
</summary>
</member>
<member name="M:List.tryTake``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:List.zipBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Zip two lists by a function.
 TODO: optimize with program fusion.
</summary>
</member>
<member name="M:List.roll``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Threads a computation state through the adjacent members of a list.
</summary>
</member>
<member name="M:List.forall2Plus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 For all 2 that indicates uneven lists by returning false rather than raising.
</summary>
</member>
<member name="M:List.tryFindAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Try to find a value at index n.
</summary>
</member>
<member name="M:List.tryFindPlus``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Try to find a value.
</summary>
</member>
<member name="M:List.areSameLength``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Query that two lists are of the same length.
</summary>
</member>
<member name="M:List.hasBetween``1(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has at least n elements.
</summary>
</member>
<member name="M:List.hasExactly``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has exactly n elements.
</summary>
</member>
<member name="M:List.hasAtMost``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has at most n elements.
</summary>
</member>
<member name="M:List.hasAtLeast``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Query that a list has at least n elements.
</summary>
</member>
<member name="M:List.partitionPlus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partition a list.
</summary>
</member>
<member name="M:List.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check that a predicate passes for NO items in a list.
</summary>
</member>
<member name="M:List.flipCons``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Cons with flipped arguments.
</summary>
</member>
<member name="M:List.cons``1">
<summary>
 The missing cons function.
</summary>
</member>
<member name="T:Prime.AddressConverter">
<summary>
 Converts Address types.
</summary>
</member>
<member name="M:Prime.Address`1.op_MinusLessMinus``1(Prime.Address{System.Object},Prime.Address{``0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.Address`1.op_MinusLessLessMinus``2(Prime.Address{``0},Prime.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.Address`1.op_MinusGreaterMinus``1(Prime.Address{``0},Prime.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.Address`1.op_MinusGreaterGreaterMinus``2(Prime.Address{``0},Prime.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.Address`1.op_MinusBarMinus``1(Prime.Address{``0},Prime.Address{``0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="M:Prime.Address`1.makeFromFullName(Prime.Name)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
 NOTE: do not move this function as the AddressConverter&apos;s reflection code relies on it being exactly here!
</summary>
</member>
<member name="M:Prime.Address`1.hash(Prime.Address{`0})">
<summary>
 Hash an Address.
</summary>
</member>
<member name="M:Prime.Address`1.equals``2(Prime.Address{``0},Prime.Address{``1})">
<summary>
 Equate Addresses.
</summary>
</member>
<member name="M:Prime.Address`1.compare``2(Prime.Address{``0},Prime.Address{``1})">
<summary>
 Compare Addresses.
</summary>
</member>
<member name="T:Prime.Address`1">
<summary>
 Specifies the address of an identifiable value.
</summary>
</member>
<member name="T:Prime.BoxableSubscription`1">
<summary>
 Describes an event subscription that can be boxed / unboxed.
</summary>
</member>
<member name="T:Prime.Chain`3">
<summary>
 The Chain monad. Allows the user to define a chain of operations over the world that
 optionally spans across a bounded number of events.
</summary>
</member>
<member name="T:Prime.Either`2">
<summary>
 Haskell-style Either type.
</summary>
</member>
<member name="T:Prime.EventSystem`1">
<summary>
 A publisher-neutral, purely functional event system.
</summary>
</member>
<member name="T:Prime.Event`2">
<summary>
 An event used by the event system.
</summary>
</member>
<member name="T:Prime.Eventable`1">
<summary>
 Adds the capability to use purely-functional events with the given type &apos;w.
</summary>
</member>
<member name="T:Prime.Handling">
<summary>
 Describes whether an in-flight event has been resolved or should cascade to down-stream handlers.
</summary>
</member>
<member name="T:Prime.Hkv`2">
<summary>
 A hash-key-value triple, implemented with a struct for efficiency.
</summary>
</member>
<member name="T:Prime.Id">
<summary>
 A generalized identification code.
</summary>
</member>
<member name="T:Prime.KeyedCache`2">
<summary>
 Presents a purely-functional interface to a cached value.
</summary>
</member>
<member name="T:Prime.LabelName">
<summary>
 Along with the Label binding, is used to elaborate the name of a target without using a
 string literal.
</summary>
</member>
<member name="T:Prime.Liveness">
<summary>
 Specifies whether an event-based application is running or exiting.
</summary>
</member>
<member name="T:Prime.MutantCache`1">
<summary>
 Presents a purely-functional interface to a mutable object / record / whatever.
 If it is not satisfactorily efficient to run a clone operation on the mutant for every get,
 just pass in the id function for make&apos;s cloneMutant arg, but make sure to NEVER mutate the
 returned mutant!
</summary>
</member>
<member name="M:Prime.Name.make(System.String)">
<summary>
 Make a name from a non-empty string without whitespace.
</summary>
</member>
<member name="M:Prime.Name.equals(Prime.Name,Prime.Name)">
<summary>
 Equate Names.
</summary>
</member>
<member name="M:Prime.Name.compare(Prime.Name,Prime.Name)">
<summary>
 Compare Names.
</summary>
</member>
<member name="T:Prime.Name">
<summary>
 A name for optimized keying in hashing containers.
</summary>
</member>
<member name="T:Prime.NameConverter">
<summary>
 Converts Name types.
</summary>
</member>
<member name="T:Prime.Observation`3">
<summary>
 An observation in the functional reactive style.
 TODO: I bet there&apos;s either a monad or arrow here...
</summary>
</member>
<member name="T:Prime.Participant">
<summary>
 A participant in the event system.
</summary>
</member>
<member name="T:Prime.ParticipantChangeData`2">
<summary>
 The data for a change in a participant.
</summary>
</member>
<member name="M:Prime.ParticipantOperators.op_MinusGreaterMinus``1(Prime.Address{``0},Prime.Participant)">
<summary>
 Concatenate two addresses, takings the type of first address.
</summary>
</member>
<member name="M:Prime.ParticipantOperators.acatf``1(Prime.Address{``0},Prime.Participant)">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="T:Prime.ParticipantOperators">
<summary>
 Operators for the Participant type.
</summary>
</member>
<member name="T:Prime.Rand">
<summary>
 An immutable random number generator using the xorshift* algorithm.
</summary>
</member>
<member name="T:Prime.RelationConverter">
<summary>
 Converts Relation types.
</summary>
</member>
<member name="M:Prime.Relation`1.makeFromFullName(Prime.Name)">
<summary>
 Make a relation from a &apos;/&apos; delimited string where &apos;.&apos; are empty.
 NOTE: do not move this function as the RelationConverter&apos;s reflection code relies on it being exactly here!
</summary>
</member>
<member name="M:Prime.Relation`1.hash(Prime.Relation{`0})">
<summary>
 Hash a Relation.
</summary>
</member>
<member name="M:Prime.Relation`1.equals``2(Prime.Relation{``0},Prime.Relation{``1})">
<summary>
 Equate Relations.
</summary>
</member>
<member name="T:Prime.Relation`1">
<summary>
 A relation that can be resolved to an address via projection.
</summary>
</member>
<member name="T:Prime.SubscriptionEntries">
<summary>
 A map of event subscriptions.
</summary>
</member>
<member name="T:Prime.SubscriptionEntry">
<summary>
 An entry in the subscription map.
</summary>
</member>
<member name="T:Prime.SubscriptionSorter`1">
<summary>
 Abstracts over a subscription sorting procedure.
</summary>
</member>
<member name="T:Prime.Subscription`3">
<summary>
 Describes an event subscription.
</summary>
</member>
<member name="T:Prime.SymbolicCompression`2">
<summary>
 Compresses two unions into a single union in a symbolic-expression.
</summary>
</member>
<member name="T:Prime.UnsubscriptionEntries">
<summary>
 A map of subscription keys to unsubscription data.
</summary>
</member>
<member name="T:Prime.Vmap`2">
<summary>
 A very fast persistent hash map.
 TODO: document.
 TODO: implement filter.
</summary>
</member>
<member name="T:Prime.Vnode`2">
<summary>
 TODO: there&apos;s an F# issue where UseNullAsTrueValue does not work on unions with 4 or more cases
 https://github.com/Microsoft/visualfsharp/issues/711 . Once resolved, should use it and be able
 to make arrays with Array.zeroCreate alone without also copying over the empty array.
</summary>
</member>
<member name="T:Prime.VsyncBuilder">
<summary>
 The Vsync computation expression builder.
</summary>
</member>
<member name="T:Prime.Vsync`1">
<summary>
 The &apos;Vsync&apos; (AKA, &apos;Variable Synchrony&apos;) monad.
 NOTE: to reference how all this stuff works in F#, see here - https://msdn.microsoft.com/en-us/library/dd233182.aspx
 TODO: forward documentation from FSharp.Core.
</summary>
</member>
<member name="T:Prime.XDefaultValueAttribute">
<summary>
 An attribute to specify the default value of an XField.
</summary>
</member>
<member name="T:Prime.XField">
<summary>
 An Xtension field.
</summary>
</member>
<member name="T:Prime.XFieldDescriptor">
<summary>
 Describes an XField.
</summary>
</member>
<member name="T:Prime.XFields">
<summary>
 An indexible collection of XFields.
</summary>
</member>
<member name="M:Prime.Xtension.tryGetDefaultValue``1(Prime.Xtension,System.String)">
<summary>
 Try to get the default value for a given xtension member, returning None when defaulting is disallowed.
</summary>
</member>
<member name="M:Prime.Xtension.op_DynamicAssignment``1(Prime.Xtension,System.String,``0)">
<summary>
 The dynamic assignment operator for an Xtension.
 Example:
     let entity = entity.Position &lt;- Vector2 (4.0, 5.0).
</summary>
</member>
<member name="M:Prime.Xtension.op_Dynamic``1(Prime.Xtension,System.String)">
<summary>
 The dynamic look-up operator for an Xtension.
 Example:
     let parallax = entity?Parallax : single
</summary>
</member>
<member name="M:Prime.Xtension.getDefaultValue``1">
<summary>
 Get the default value of an instance of type &apos;r taking into account XDefaultValue decorations.
</summary>
</member>
<member name="T:Prime.Xtension">
<summary>
 Xtensions (and their supporting types) are a dynamic, functional, and semi-convenient way
 to implement dynamic fields.
 TODO: use DebuggerTypeProxyAttribute to make xFields easier to browse in the debugger.
 TODO: make this an abstract data type.
</summary>
</member>
<member name="T:Prime.rQueue`1">
<summary>
 Type alias to emphasize that messages arrive in a reversed queue since I am
 too lazy to write an immutable queue directly.

 TODO: replace all usage with Queue from FSharpx.Collections.
</summary>
</member>
<member name="M:Prime.Address.isEmpty``1(Prime.Address{``0})">
<summary>
 Query that an address is devoid of names.
</summary>
</member>
<member name="M:Prime.Address.length``1(Prime.Address{``0})">
<summary>
 Get the length of an address by its names.
</summary>
</member>
<member name="M:Prime.Address.allButLast``2(Prime.Address{``0})">
<summary>
 Take an address composed of all but the last name of an address.
</summary>
</member>
<member name="M:Prime.Address.last``1(Prime.Address{``0})">
<summary>
 Take the last name of an address.
</summary>
</member>
<member name="M:Prime.Address.take``2(System.Int32,Prime.Address{``0})">
<summary>
 Take an address composed of the given number of names of an address.
</summary>
</member>
<member name="M:Prime.Address.skip``2(System.Int32,Prime.Address{``0})">
<summary>
 Take an address composed of the name of an address minus a skipped amount of names.
</summary>
</member>
<member name="M:Prime.Address.item``1(System.Int32,Prime.Address{``0})">
<summary>
 Take a name of an address.
</summary>
</member>
<member name="M:Prime.Address.tail``1(Prime.Address{System.Object})">
<summary>
 Take the tail of an address.
</summary>
</member>
<member name="M:Prime.Address.head``1(Prime.Address{``0})">
<summary>
 Take the head of an address.
</summary>
</member>
<member name="M:Prime.Address.getHashCode``1(Prime.Address{``0})">
<summary>
 Get the address&apos;s hash code.
</summary>
</member>
<member name="M:Prime.Address.getName``1(Prime.Address{``0})">
<summary>
 Get the name of an address.
</summary>
</member>
<member name="M:Prime.Address.getFullName``1(Prime.Address{``0})">
<summary>
 Get the full name of an address.
</summary>
</member>
<member name="M:Prime.Address.changeType``2(Prime.Address{``0})">
<summary>
 Change the type of an address.
</summary>
</member>
<member name="M:Prime.Address.getNames``1(Prime.Address{``0})">
<summary>
 Get the names of an address.
</summary>
</member>
<member name="M:Prime.Address.makeFromFullName``1(Prime.Name)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
</summary>
</member>
<member name="M:Prime.Address.makeFromNames``1(Microsoft.FSharp.Collections.FSharpList{Prime.Name})">
<summary>
 Make an address from names.
</summary>
</member>
<member name="M:Prime.Address.empty``1">
<summary>
 The empty address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatsf``2(Prime.Address{``0},Prime.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acats``1(Prime.Address{System.Object},Prime.Address{``0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatff``2(Prime.Address{``0},Prime.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatf``1(Prime.Address{``0},Prime.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acat``1(Prime.Address{``0},Prime.Address{``0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="M:Prime.AddressOperators.atooa``1(Prime.Address{``0})">
<summary>
 Convert any address to an obj Address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ntoa``1(Prime.Name)">
<summary>
 Convert a single name into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ftoa``1(Prime.Name)">
<summary>
 Convert a full name into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ltoa``1(Microsoft.FSharp.Collections.FSharpList{Prime.Name})">
<summary>
 Convert a names list into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.atoa``2(Prime.Address{``0})">
<summary>
 Convert an address of type &apos;a to an address of type &apos;b.
</summary>
</member>
<member name="M:Prime.Async.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 The missing Async.Map function.
</summary>
</member>
<member name="T:Prime.Async">
<summary>
 Async is missing a couple of functions, as we know...
</summary>
</member>
<member name="M:Prime.Chain.runAssumingResolve``3(Prime.Chain{Prime.Event{``0,``1},Microsoft.FSharp.Core.Unit,``2},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Run a chain over Nu&apos;s event system.
 Allows each chainhronized operation to run without referencing its source event, and
 without specifying its event handling approach by assuming Resolve.
</summary>
</member>
<member name="M:Prime.Chain.runAssumingCascade``3(Prime.Chain{Prime.Event{``0,``1},Microsoft.FSharp.Core.Unit,``2},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Run a chain over Nu&apos;s event system.
 Allows each chainhronized operation to run without referencing its source event, and
 without specifying its event handling approach by assuming Cascade.
</summary>
</member>
<member name="M:Prime.Chain.run``2(Prime.Chain{Microsoft.FSharp.Core.Unit,``0,``1},``1)">
<summary>
 Run a chain to its end, providing unit for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.run2``2(Prime.Chain{Microsoft.FSharp.Core.Unit,``0,``1},``1)">
<summary>
 Run a chain to its end, providing unit for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.run3``3(Prime.Chain{``0,``1,``2},``0,``2)">
<summary>
 Run a chain to its end, providing &apos;e&apos; for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.advance``3(Microsoft.FSharp.Core.FSharpFunc{``0,Prime.Chain{``0,``1,``2}},``0,``2)">
<summary>
 Advance a chain value by one step, providing &apos;e&apos;.
</summary>
</member>
<member name="M:Prime.Chain.step``3(Prime.Chain{``0,``1,``2},``2)">
<summary>
 Step once into a chain.
</summary>
</member>
<member name="M:Prime.Chain.during``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Prime.Chain{``1,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Loop in a chain context while &apos;pred&apos; evaluates to true.
</summary>
</member>
<member name="M:Prime.Chain.loop``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.Chain{``2,Microsoft.FSharp.Core.Unit,``1}})">
<summary>
 Loop in a chain context while &apos;pred&apos; evaluate to true.
</summary>
</member>
<member name="M:Prime.Chain.react``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 React to the next event, discarding the event&apos;s value.
</summary>
</member>
<member name="M:Prime.Chain.reactE``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}})">
<summary>
 React to the next event, using the event&apos;s value in the reaction.
</summary>
</member>
<member name="M:Prime.Chain.pass``2">
<summary>
 Pass over the next event.
</summary>
</member>
<member name="M:Prime.Chain.next``2">
<summary>
 Get the next event.
</summary>
</member>
<member name="M:Prime.Chain.update``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Update the world.
</summary>
</member>
<member name="M:Prime.Chain.updateBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Update the world with an additional transformed world parameter.
</summary>
</member>
<member name="M:Prime.Chain.set``2(``0)">
<summary>
 Set the world.
</summary>
</member>
<member name="M:Prime.Chain.getBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Get the world transformed by &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Chain.get``2">
<summary>
 Get the world.
</summary>
</member>
<member name="M:Prime.Chain.bind``4">
<summary>
 Monadic bind for the chain monad.
</summary>
</member>
<member name="M:Prime.Chain.returnM``3">
<summary>
 Monadic return for the chain monad.
</summary>
</member>
<member name="T:Prime.ChainBuilder.ChainBuilder">
<summary>
 Implements the chain monad.
</summary>
</member>
<member name="P:Prime.ChainBuilder.chain">
<summary>
 Builds the chain monad.
</summary>
</member>
<member name="M:Prime.ChainBuilder.bind``4(Prime.Chain{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Chain{``0,``3,``2}})">
<summary>
 Monadic bind for the chain monad.
</summary>
</member>
<member name="M:Prime.ChainBuilder.returnM``3(``0)">
<summary>
 Monadic return for the chain monad.
</summary>
</member>
<member name="M:Prime.Dictionary.dictC``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Like dict, but returns a concrete Dictionary instance with structural hashing.
</summary>
</member>
<member name="M:Prime.Dictionary.tryFind``2(``0,System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Try to find a value in a dictonary.
</summary>
</member>
<member name="M:Prime.Dictionary.map``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.KeyValuePair{``0,``1},``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Map over a dictionary. A new dictionary is produced.
</summary>
</member>
<member name="M:Prime.Dictionary.singleton``2(``0,``1)">
<summary>
 Make a dictionary with a single element.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.Consume``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Add all the elements of another dictionary.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.AddMany``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Add multiple kvps to a dictionary.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.ValueEquals``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Check value equality of dictionary.
 NOTE: be wary the highly imperative nature of this code.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.ForceAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
<summary>
 Force the addition of an element, removing the existing one if necessary.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.TryAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
<summary>
 Try to add an element, returning false upon failure.
</summary>
</member>
<member name="T:Prime.Either.EitherBuilder">
<summary>
 Builds an either monad.
</summary>
</member>
<member name="M:Prime.Either.split``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Split a sequences of Either values into a pair of left and right value lists.
</summary>
</member>
<member name="M:Prime.Either.mapRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Either{``2,``0})">
<summary>
 Map over the right side of an Either value.
</summary>
</member>
<member name="M:Prime.Either.mapLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Either{``0,``2})">
<summary>
 Map over the left side of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getRightValues``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Get only the Right values of a sequence of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getLeftValues``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Get only the Left values of a sequence of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getRightValue``2(Prime.Either{``0,``1})">
<summary>
 Get the Right value of an Either value, failing if not available.
</summary>
</member>
<member name="M:Prime.Either.getLeftValue``2(Prime.Either{``0,``1})">
<summary>
 Get the Left value of an Either value, failing if not available.
</summary>
</member>
<member name="M:Prime.Either.isRight``2(Prime.Either{``0,``1})">
<summary>
 Query whether an Either value is a Right value.
</summary>
</member>
<member name="M:Prime.Either.isLeft``2(Prime.Either{``0,``1})">
<summary>
 Query whether an Either value is a Left value.
</summary>
</member>
<member name="P:Prime.Either.either">
<summary>
 The computation expression builder for Either.
</summary>
</member>
<member name="M:Prime.Either.bind``3(Prime.Either{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``0,``2}})">
<summary>
 Monadic bind for Either.
</summary>
</member>
<member name="M:Prime.Either.returnM``2(``0)">
<summary>
 Monadic return for Either.
</summary>
</member>
<member name="M:Prime.EventSystemModule.make``1">
<summary>
 Make an event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.getEventState``2(System.Guid,Prime.EventSystem{``1})">
<summary>
 Get event state.
</summary>
</member>
<member name="M:Prime.EventSystemModule.setUnsubscriptions``1(Prime.Vmap{System.Guid,System.Tuple{Prime.Address{System.Object},Prime.Participant}},Prime.EventSystem{``0})">
<summary>
 Set unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.setSubscriptions``1(Prime.Vmap{Prime.Address{System.Object},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}},Prime.EventSystem{``0})">
<summary>
 Set subscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.getUnsubscriptions``1(Prime.EventSystem{``0})">
<summary>
 Get unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.getSubscriptions``1(Prime.EventSystem{``0})">
<summary>
 Get subscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.removeEventState``1(System.Guid,Prime.EventSystem{``0})">
<summary>
 Remove event state.
</summary>
</member>
<member name="M:Prime.EventSystemModule.addEventState``2(System.Guid,``0,Prime.EventSystem{``1})">
<summary>
 Add event state.
</summary>
</member>
<member name="M:Prime.EventableModule.monitor``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Address{``0},``1,``2)">
<summary>
 Keep active a subscription for the lifetime of a participant.
</summary>
</member>
<member name="M:Prime.EventableModule.monitorPlus``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Address{``0},``1,``2)">
<summary>
 Keep active a subscription for the lifetime of a participant, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.EventableModule.subscribe``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Address{``0},``1,``2)">
<summary>
 Subscribe to an event.
</summary>
</member>
<member name="M:Prime.EventableModule.subscribe5``3(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Address{``0},``1,``2)">
<summary>
 Subscribe to an event using the given subscriptionKey.
</summary>
</member>
<member name="M:Prime.EventableModule.subscribePlus``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Address{``0},``1,``2)">
<summary>
 Subscribe to an event, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.EventableModule.subscribePlus5``3(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Address{``0},``1,``2)">
<summary>
 Subscribe to an event using the given subscriptionKey, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.EventableModule.unsubscribe``1(System.Guid,``0)">
<summary>
 Unsubscribe from an event.
</summary>
</member>
<member name="M:Prime.EventableModule.publish``3(``0,Prime.Address{``0},Microsoft.FSharp.Collections.FSharpList{System.String},``1,``2)">
<summary>
 Publish an event with no subscription sorting.
</summary>
</member>
<member name="M:Prime.EventableModule.publish6``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}},``0,Prime.Address{``0},Microsoft.FSharp.Collections.FSharpList{System.String},``1,``2)">
<summary>
 Publish an event, using the given publishSorter procedure to arrange the order to which subscriptions are published.
</summary>
</member>
<member name="M:Prime.EventableModule.publish7``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}},Microsoft.FSharp.Core.FSharpFunc{Prime.Address{System.Object},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}}},``0,Prime.Address{``0},Microsoft.FSharp.Collections.FSharpList{System.String},``1,``2)">
<summary>
 Publish an event, using the given getSubscriptions and publishSorter procedures to arrange the order to which subscriptions are published.
</summary>
</member>
<member name="M:Prime.EventableModule.sortSubscriptionsNone``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},``0)">
<summary>
 A &apos;no-op&apos; for subscription sorting - that is, performs no sorting at all.
</summary>
</member>
<member name="M:Prime.EventableModule.sortSubscriptionsBy``1(Microsoft.FSharp.Core.FSharpFunc{Prime.Participant,Microsoft.FSharp.Core.FSharpFunc{``0,System.Single}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}},``0)">
<summary>
 Sort subscriptions using categorization via the &apos;by&apos; procedure.
</summary>
</member>
<member name="M:Prime.EventableModule.getEventState``2(System.Guid,``1)">
<summary>
 Get event state from the world.
</summary>
</member>
<member name="M:Prime.EventableModule.removeEventState``1(System.Guid,``0)">
<summary>
 Remove event state from the world.
</summary>
</member>
<member name="M:Prime.EventableModule.addEventState``2(System.Guid,``0,``1)">
<summary>
 Add event state to the world.
</summary>
</member>
<member name="M:Prime.EventableModule.setUnsubscriptions``1(Prime.Vmap{System.Guid,System.Tuple{Prime.Address{System.Object},Prime.Participant}},``0)">
<summary>
 Set event unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventableModule.setSubscriptions``1(Prime.Vmap{Prime.Address{System.Object},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Guid,Prime.Participant,System.Object}}},``0)">
<summary>
 Set event subscriptions.
</summary>
</member>
<member name="M:Prime.EventableModule.getUnsubscriptions``1(``0)">
<summary>
 Get event unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventableModule.getSubscriptions``1(``0)">
<summary>
 Get event subscriptions.
</summary>
</member>
<member name="P:Prime.Events.Any">
<summary>
 Represents any event.
</summary>
</member>
<member name="M:Prime.HashSet.singleton``1(``0)">
<summary>
 Make a hash set with a single element.
</summary>
</member>
<member name="M:Prime.HashSetExtension.HashSet`1.ForceAdd``1(System.Collections.Generic.HashSet{``0},``0)">
<summary>
 Force the addition of an element, removing the existing one if necessary.
</summary>
</member>
<member name="M:Prime.IdModule.makeIdMaker">
<summary>
 Make a function that gets a unique number.
 TODO: place a mutex lock in this
</summary>
</member>
<member name="P:Prime.IdModule.InvalidId">
<summary>
 The invalid Id.
</summary>
</member>
<member name="P:Prime.LabelNameModule.Module">
<summary>
 Label for module names.
 Needed since we can&apos;t utter something like typeof&lt;MyModule&gt;.
</summary>
</member>
<member name="P:Prime.LabelNameModule.Label">
<summary>
 Along with the LabelName type, is used to elaborate the name of a target without
 using a string literal.

 Usage:
     let fieldName = Label?MyFieldName
</summary>
</member>
<member name="M:Prime.Lens.fuse``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``0,``2})">
<summary>
 Combine two lenses into a single subject.
</summary>
</member>
<member name="M:Prime.Lens.updateS``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},FSharpx.Lens{``1,``0},``1)">
<summary>
 Update lens with subject in tow.
</summary>
</member>
<member name="M:Prime.LensOperators.op_AtMinusGreater``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``0,``2})">
<summary>
 Combine two lenses into a single subject.
</summary>
</member>
<member name="M:Prime.Log.init(Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Initialize logging.
</summary>
</member>
<member name="M:Prime.Log.traceIf(System.Boolean,System.String)">
<summary>
 Conditional trace call where condition is eagerly evaluted.
</summary>
</member>
<member name="M:Prime.Log.trace(System.String)">
<summary>
 Log a message with a Trace.Fail and call to note.
</summary>
</member>
<member name="M:Prime.Log.debugIf(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},System.String)">
<summary>
 Conditional debug call where condition is lazily evaluated.
</summary>
</member>
<member name="M:Prime.Log.debug(System.String)">
<summary>
 Log a message with Debug.Fail and call to note.
</summary>
</member>
<member name="M:Prime.Log.note(System.String)">
<summary>
 Log a message with a Trace.WriteLine.
</summary>
</member>
<member name="M:Prime.Map.concat``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in the case of a key
 conflict.
</summary>
</member>
<member name="M:Prime.Map.objectify``2(``0,``1)">
<summary>
 Convert any map value to an obj.
</summary>
</member>
<member name="M:Prime.Map.toValueListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
<summary>
 Convert a list of a map&apos;s values by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a list of a map&apos;s values.
</summary>
</member>
<member name="M:Prime.Map.toKeyListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``2})">
<summary>
 Convert a list of a map&apos;s keys by a function.
</summary>
</member>
<member name="M:Prime.Map.toKeyList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a list of a map&apos;s keys.
</summary>
</member>
<member name="M:Prime.Map.toListBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Convert a map to a list by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.ofListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Make a map from a list by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.toValueSeqBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{System.Tuple{``3,``0},``1})">
<summary>
 Convert a seq of a map&apos;s values by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a seq of a map&apos;s values.
</summary>
</member>
<member name="M:Prime.Map.toKeySeqBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{System.Tuple{``0,``3},``1})">
<summary>
 Convert a seq of a map&apos;s keys by a function.
</summary>
</member>
<member name="M:Prime.Map.toKeySeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a seq of a map&apos;s keys.
</summary>
</member>
<member name="M:Prime.Map.toSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Convert a map to a seq by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.ofSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Make a map from a seq by a function.
 TODO: Optimize by program fusion.
</summary>
</member>
<member name="M:Prime.Map.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Add multiple values to a map.
</summary>
</member>
<member name="M:Prime.Map.singleton``2(``0,``1)">
<summary>
 Make a singleton map.
</summary>
</member>
<member name="M:Prime.MapOperators.op_AtAt``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in case of a key overlap.
</summary>
</member>
<member name="P:Prime.NameModule.empty">
<summary>
 The empty name, consisting of an empty string.
</summary>
</member>
<member name="M:Prime.NameModule.hashNames(Microsoft.FSharp.Collections.FSharpList{Prime.Name})">
<summary>
 Hash a list of names.
</summary>
</member>
<member name="M:Prime.NameModule.compareNames(Microsoft.FSharp.Collections.FSharpList{Prime.Name},Microsoft.FSharp.Collections.FSharpList{Prime.Name})">
<summary>
 Compare a list of names lexicographically.
</summary>
</member>
<member name="M:Prime.NameModule.equateNames(Microsoft.FSharp.Collections.FSharpList{Prime.Name},Microsoft.FSharp.Collections.FSharpList{Prime.Name})">
<summary>
 Query for equality a list of names lexicographically.
</summary>
</member>
<member name="M:Prime.NameModule.split(System.Char[],Prime.Name)">
<summary>
 Split a name on a separator char array.
</summary>
</member>
<member name="M:Prime.NameModule.join(System.String,System.Collections.Generic.IEnumerable{Prime.Name})">
<summary>
 Join a list of names by a separator string.
</summary>
</member>
<member name="M:Prime.NameModule.getNameStr(Prime.Name)">
<summary>
 Get the name of a name key.
</summary>
</member>
<member name="M:Prime.NameOperators.op_BangBang(System.String)">
<summary>
 Convert a name string to a name.
</summary>
</member>
<member name="M:Prime.Observation.participantValue``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Observation{Prime.ParticipantChangeData{``2,``0},``3,``0})">
<summary>
 Filter out participant change events that do not relate to those returned by &apos;valueGetter&apos;.
</summary>
</member>
<member name="M:Prime.Observation.distinct``3(Prime.Observation{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0})">
<summary>
 Filter out the events with non-unique data from an observation.
</summary>
</member>
<member name="M:Prime.Observation.distinctBy``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Filter out the events with non-unique data as defined by &apos;by&apos; from an observation.
</summary>
</member>
<member name="M:Prime.Observation.min``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running minimum of it numeric data.
</summary>
</member>
<member name="M:Prime.Observation.max``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running maximum of it numeric data.
</summary>
</member>
<member name="M:Prime.Observation.choose``3(Prime.Observation{Microsoft.FSharp.Core.FSharpOption{``0},``1,``2})">
<summary>
 Filter out the None data values from an observation and strip the Some constructor from
 the remaining values.
</summary>
</member>
<member name="M:Prime.Observation.search``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Boolean}},Prime.Observation{``0,``1,``2})">
<summary>
 Take only the first event from an observation that satisfies &apos;p&apos;.
</summary>
</member>
<member name="M:Prime.Observation.nth``3(System.Int32,Prime.Observation{``0,``1,``2})">
<summary>
 Take only the nth event from an observation.
</summary>
</member>
<member name="M:Prime.Observation.tail``3(Prime.Observation{``0,``1,``2})">
<summary>
 Skip the first event of an observation.
</summary>
</member>
<member name="M:Prime.Observation.head``3(Prime.Observation{``0,``1,``2})">
<summary>
 Take only the first event from an observation.
</summary>
</member>
<member name="M:Prime.Observation.skip``3(System.Int32,Prime.Observation{``0,``1,``2})">
<summary>
 Skip the first n events in an observation.
</summary>
</member>
<member name="M:Prime.Observation.take``3(System.Int32,Prime.Observation{``0,``1,``2})">
<summary>
 Take only the first n events from an observation.
</summary>
</member>
<member name="M:Prime.Observation.duplicate``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation by duplicating its data into pairs.
</summary>
</member>
<member name="M:Prime.Observation.withSnd``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Observation{System.Tuple{``2,``0},``3,``4})">
<summary>
 Transform an observation of pairs by a mapping of its snd values.
</summary>
</member>
<member name="M:Prime.Observation.withFst``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Observation{System.Tuple{``0,``2},``3,``4})">
<summary>
 Transform an observation&apos;s pairs by a mapping of its fst values.
</summary>
</member>
<member name="M:Prime.Observation.toSnd``4(Prime.Observation{System.Tuple{``0,``1},``2,``3})">
<summary>
 Transform an observation of pairs into its snd values.
</summary>
</member>
<member name="M:Prime.Observation.toFst``4(Prime.Observation{System.Tuple{``0,``1},``2,``3})">
<summary>
 Transform an observation of pairs into its fst values.
</summary>
</member>
<member name="M:Prime.Observation.productN``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running product of its data.
</summary>
</member>
<member name="M:Prime.Observation.sumN``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running sum of its data.
</summary>
</member>
<member name="M:Prime.Observation.group``3(Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running set of its event&apos;s unique data.
</summary>
</member>
<member name="M:Prime.Observation.groupBy``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running set of its event&apos;s unique data as defined by &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Observation.organize``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Transform an observation into a running map from its event&apos;s data to keys as defined by &apos;f&apos;.
</summary>
</member>
<member name="M:Prime.Observation.average``4(Prime.Observation{``0,``2,``3})">
<summary>
 Transform an observation into a running average of its event&apos;s numeric data.
</summary>
</member>
<member name="M:Prime.Observation.scan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0}}},``0,Prime.Observation{``1,``2,``3})">
<summary>
 Scan over an observation, accumulating state.
</summary>
</member>
<member name="M:Prime.Observation.scan2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Prime.Observation{``0,``1,``2})">
<summary>
 Scan over an observation, accumulating state.
</summary>
</member>
<member name="M:Prime.Observation.scan4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,``4},``0,Prime.Observation{``1,``2,``3})">
<summary>
 Scan over an observation, accumulating state.
</summary>
</member>
<member name="M:Prime.Observation.monitor``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation until the observer is removed from the world.
</summary>
</member>
<member name="M:Prime.Observation.monitorWithUnsub``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation until the observer is removed from the world,
 returning both an unsubscription procedure as well as the world as augmented with said
 subscription.
</summary>
</member>
<member name="M:Prime.Observation.lifetime``3(Prime.Observation{``0,``1,``2})">
<summary>
 Terminate an observation when the observer is removed from the world.
</summary>
</member>
<member name="M:Prime.Observation.until``3(Prime.Address{Microsoft.FSharp.Core.Unit},Prime.Observation{``0,``1,``2})">
<summary>
 Terminate an observation when an event at the given address is raised.
</summary>
</member>
<member name="M:Prime.Observation.subscribe``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation, handling each event with the given &apos;handleEvent&apos; procedure.
</summary>
</member>
<member name="M:Prime.Observation.subscribePlus``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},Prime.Observation{``0,``1,``2},``2)">
<summary>
 Subscribe to an observation, handling each event with the given &apos;handleEvent&apos; procedure,
 returning both an unsubscription procedure as well as the world as augmented with said
 subscription.
</summary>
</member>
<member name="M:Prime.Observation.track``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,System.Boolean}}},``0,Prime.Observation{``2,``3,``1})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Observation.track2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,System.Boolean}}}},Prime.Observation{``0,``1,``2})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Observation.track4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,System.Boolean}}}},Microsoft.FSharp.Core.FSharpFunc{``0,``4},``0,Prime.Observation{``1,``2,``3})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Observation.map``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Observation{``0,``1,``2})">
<summary>
 Map an observation by the given &apos;mapper&apos; procedure.
</summary>
</member>
<member name="M:Prime.Observation.filter``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Boolean}},Prime.Observation{``0,``1,``2})">
<summary>
 Filter an observation by the given &apos;pred&apos; procedure.
</summary>
</member>
<member name="M:Prime.Observation.sum``4(Prime.Address{``0},Prime.Observation{``1,``2,``3})">
<summary>
 Combine an observation with the events from the given address. Combination is in &apos;sum
 form&apos;, which is defined as an Either of the data of the combined events, where only data
 from the most recent event is available at a time.
</summary>
</member>
<member name="M:Prime.Observation.product``4(Prime.Address{``0},Prime.Observation{``1,``2,``3})">
<summary>
 Combine an observation with the events from the given address. Combination is in &apos;product
 form&apos;, which is defined as a pair of the data of the combined events. Think of it as &apos;zip&apos;
 for event streams.
 NOTE: This function is currently broken.
 TODO: fix by implementing this with event state instead of the rat&apos;s nest of subscriptions.
</summary>
</member>
<member name="M:Prime.Observation.observe``3(Prime.Address{``0},``1)">
<summary>
 Make an observation of an event at the given address.
</summary>
</member>
<member name="M:Prime.ObservationModule.op_MinusMinusGreater``3(Prime.Observation{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``2}})">
<summary>
 Propagate the event data of an observation to a value in the observing participant when the
 observer exists (doing nothing otherwise).
</summary>
</member>
<member name="M:Prime.ObservationModule.op_MultiplyMinusMinus``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2},``3)">
<summary>
 Make an observation of the observer&apos;s change events.
</summary>
</member>
<member name="M:Prime.ObservationModule.op_MinusBarGreater``2">
<summary>
 Pipe-right arrow that provides special precedence for observations.
</summary>
</member>
<member name="M:Prime.Operators.op_EqualsEqualsEquals``1(``0,``0)">
<summary>
 Test just the value parts of a type for equality. Reflective and slow.
</summary>
</member>
<member name="M:Prime.Operators.op_EqualsEquals``1(``0,``0)">
<summary>
 Test for equality, usually faster than (=).
</summary>
</member>
<member name="M:Prime.Operators.op_Concatenate``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Sequences two functions like Haskell ($).
</summary>
</member>
<member name="M:Prime.Operators.implicit``2(``0)">
<summary>
 As close as we can get to F# implicits.
</summary>
</member>
<member name="M:Prime.Operators.failwithumf``1">
<summary>
 Fail with an unexpected match failure.
</summary>
</member>
<member name="M:Prime.Operators.makeGuidFromInts(System.Int32,System.Int32)">
<summary>
 Make a Guid from a couple of ints.
 It is the user&apos;s responsibility to ensure uniqueness when using the resulting Guids.
</summary>
</member>
<member name="M:Prime.Operators.makeGuid">
<summary>
 Make a Guid.
</summary>
</member>
<member name="M:Prime.Operators.enumerable``1(System.Collections.IEnumerable)">
<summary>
 Short-hand for linq enumerable cast.
</summary>
</member>
<member name="M:Prime.Operators.assignTypeConverter``2">
<summary>
 Add a custom TypeConverter to an existing type.
</summary>
</member>
<member name="M:Prime.Operators.doUntil(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean})">
<summary>
 Perform an operation until a predicate passes.
</summary>
</member>
<member name="M:Prime.Operators.doTimes``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0,System.Int32)">
<summary>
 Apply a function recursively a number of times.
</summary>
</member>
<member name="M:Prime.Operators.similar(System.Object,System.Object)">
<summary>
 Test just the value parts of a type for equality.
 NOTE: This function uses mad reflection, so is extremely slow, and should not be used in tight loops.
</summary>
</member>
<member name="M:Prime.Operators.refEq``1(``0,``0)">
<summary>
 Test for reference equality.
</summary>
</member>
<member name="M:Prime.Operators.fastEq``1(``0,``0)">
<summary>
 Test for equality, usually faster than (=).
</summary>
</member>
<member name="M:Prime.Operators.getPropertyValue(System.Object[],System.Reflection.PropertyInfo,System.Object)">
<summary>
 Get the value of a property.
</summary>
</member>
<member name="M:Prime.Operators.getProperties(System.Type)">
<summary>
 Get the properties of a type.
</summary>
</member>
<member name="M:Prime.Operators.getFieldValue(System.Reflection.FieldInfo,System.Object)">
<summary>
 Get the value of a field.
</summary>
</member>
<member name="M:Prime.Operators.getFields(System.Type)">
<summary>
 Get the fields of a type.
</summary>
</member>
<member name="M:Prime.Operators.getTypeName``1(``0)">
<summary>
 Get the .NET type name of a target.
</summary>
</member>
<member name="M:Prime.Operators.getType``1(``0)">
<summary>
 Get the .NET type of a target.
</summary>
</member>
<member name="M:Prime.Operators.strCmp(System.String,System.String)">
<summary>
 Compare two strings.
</summary>
</member>
<member name="M:Prime.Operators.strEq(System.String,System.String)">
<summary>
 Test for string equality.
</summary>
</member>
<member name="M:Prime.Operators.denull``1(``0)">
<summary>
 Convert a nullable value into an option.
</summary>
</member>
<member name="M:Prime.Operators.isNotNull``1(``0)">
<summary>
 Test for non-null.
</summary>
</member>
<member name="M:Prime.Operators.isNull``1(``0)">
<summary>
 Test for null.
</summary>
</member>
<member name="M:Prime.Operators.flip4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}}},``1,``2,``3,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.flip3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``1,``2,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Uncurry two values.
</summary>
</member>
<member name="M:Prime.Operators.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Curry up two values.
</summary>
</member>
<member name="M:Prime.Operators.objectify``1(``0)">
<summary>
 Convert any value to an obj.
</summary>
</member>
<member name="M:Prime.Operators.absurdity2``2(``0,``1)">
<summary>
 The absurdity function with two arguments.
 No matter what you pass it, it evaluates to false.
</summary>
</member>
<member name="M:Prime.Operators.absurdity``1(``0)">
<summary>
 The absurdity function.
 No matter what you pass it, it evaluates to false.
</summary>
</member>
<member name="M:Prime.Operators.tautology3``3(``0,``1,``2)">
<summary>
 The tautology function with three arguments.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.tautology2``2(``0,``1)">
<summary>
 The tautology function with two arguments.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.tautology``1(``0)">
<summary>
 The tautology function.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Option.getOrDefault``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Get an option&apos;s value, or missing that, return a default value.
</summary>
</member>
<member name="M:Prime.Option.join``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Join an option option.
</summary>
</member>
<member name="M:Prime.Pair.sortFstDescending``2(System.Single,``0,System.Single,``1)">
<summary>
 Sort pairs by fst in descending order.
</summary>
</member>
<member name="M:Prime.Pair.make``2(``0,``1)">
<summary>
 Make a pair.
</summary>
</member>
<member name="M:Prime.PairOperators.mapSnd``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0)">
<summary>
 Map over pair member snd.
</summary>
</member>
<member name="M:Prime.PairOperators.mapFst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2)">
<summary>
 Map over pair member fst.
</summary>
</member>
<member name="M:Prime.PairOperators.withSnd``3(``0,``1,``2)">
<summary>
 Replace pair member snd.
</summary>
</member>
<member name="M:Prime.PairOperators.withFst``3(``0,``1,``2)">
<summary>
 Replace pair member fst.
</summary>
</member>
<member name="M:Prime.Program.runTimings``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.Tuple{System.String,System.String}}[],``0},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.Tuple{System.String,System.String}}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 Performs some ad-hoc tests to compare performance of maps.
</summary>
</member>
<member name="M:Prime.RandModule.make">
<summary>
 Make a rand value generator from the default seed state.
</summary>
</member>
<member name="M:Prime.RandModule.makeFromInt(System.Int32)">
<summary>
 Make a rand value generator from the given int seed state.
 May not be zero.
</summary>
</member>
<member name="M:Prime.RandModule.makeFromSeedState(System.UInt64)">
<summary>
 Make a rand value generator from the given seed state.
 May not be zero.
</summary>
</member>
<member name="M:Prime.RandModule.nextInt64Under(System.UInt64,Prime.Rand)">
<summary>
 Get the next random value below the given maximum as an int64 type.
</summary>
</member>
<member name="M:Prime.RandModule.nextInt64(Prime.Rand)">
<summary>
 Get the next random value as an int64 type.
 NOTE: System.Random.Next will never return Int64.MaxValue, but this will.
</summary>
</member>
<member name="M:Prime.RandModule.nextIntUnder(System.Int32,Prime.Rand)">
<summary>
 Get the next random value below the given maximum as an int type.
</summary>
</member>
<member name="M:Prime.RandModule.nextInt(Prime.Rand)">
<summary>
 Get the next random value as an int type.
 NOTE: System.Random.Next will never return Int32.MaxValue, but this will.
</summary>
</member>
<member name="M:Prime.RandModule.nextSingleUnder(System.Single,Prime.Rand)">
<summary>
 Get the next random value below the given maximum as a single type.
</summary>
</member>
<member name="M:Prime.RandModule.nextSingle(Prime.Rand)">
<summary>
 Get the next random value as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.nextDoubleUnder(System.Double,Prime.Rand)">
<summary>
 Get the next random value below the given maximum as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.nextDouble(Prime.Rand)">
<summary>
 Get the next random value as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.getState(Prime.Rand)">
<summary>
 The internal state of rand, useful for serialization and duplication.
</summary>
</member>
<member name="M:Prime.RandModule.advance(Prime.Rand)">
<summary>
 Advance the state of rand, thus yielding a new outcome.
</summary>
</member>
<member name="P:Prime.RandModule.DefaultSeedState">
<summary>
 The default seed state for rand.
 NOTE: number generated via http://www.random.org/bytes/
</summary>
</member>
<member name="M:Prime.RandModule.sample(Prime.Rand)">
<summary>
 Get the sample value used to generate the current random value.
</summary>
</member>
<member name="M:Prime.Relation.makeFromFullName``1(Prime.Name)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
</summary>
</member>
<member name="M:Prime.Relation.makeFromOptNamesList``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{Prime.Name}})">
<summary>
 Make a relation from a list of option names.
</summary>
</member>
<member name="M:Prime.Relation.resolve``1(Prime.Address{``0},Prime.Relation{``0})">
<summary>
 Resolve a relationship to an address.
</summary>
</member>
<member name="M:Prime.Sectioning.div``3(``0,``1)">
<summary>
 Sectioned division.
</summary>
</member>
<member name="M:Prime.Sectioning.mul``3(``0,``1)">
<summary>
 Sectioned multiplication.
</summary>
</member>
<member name="M:Prime.Sectioning.sub``3(``0,``1)">
<summary>
 Sectioned subtraction.
</summary>
</member>
<member name="M:Prime.Sectioning.add``3(``0,``1)">
<summary>
 Sectioned addition.
</summary>
</member>
<member name="M:Prime.Sectioning.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Sectioned list cons.
</summary>
</member>
<member name="M:Prime.Sectioning.dec``3(``0)">
<summary>
 Generic decrement.
</summary>
</member>
<member name="M:Prime.Sectioning.inc``3(``0)">
<summary>
 Generic increment.
</summary>
</member>
<member name="M:Prime.Sectioning.one``1">
<summary>
 The generic one value.
</summary>
</member>
<member name="M:Prime.Sectioning.zero``1">
<summary>
 The generic zero value.
</summary>
</member>
<member name="M:Prime.String.surround(System.String,System.String)">
<summary>
 Surround a string with another surrounding string.
</summary>
</member>
<member name="M:Prime.String.toArray(System.String)">
<summary>
 Convert a string to an array of characters.
 TODO: optimize this.
</summary>
</member>
<member name="M:Prime.String.withEnd(System.String,System.String)">
<summary>
 Get the string with the given ending.
</summary>
</member>
<member name="M:Prime.String.textualize(System.String)">
<summary>
 Textualize a string for usage as text.
</summary>
</member>
<member name="M:Prime.String.implode(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Converts a list of characters into a string.
</summary>
</member>
<member name="M:Prime.String.explode(System.String)">
<summary>
 Converts a string into a list of characters.
</summary>
</member>
<member name="M:Prime.SymbolIndexModule.prettyPrint(System.String)">
<summary>
 Pretty-print a string in the form an symbolic-expression.
</summary>
</member>
<member name="M:Prime.SymbolIndexModule.fromString(System.String)">
<summary>
 Attempt to a symbol index from a string.
</summary>
</member>
<member name="M:Prime.SymbolModule.toString(Prime.Symbol)">
<summary>
 Convert a symbol to a string, with the following unparses:
 
 (* Atom values *)
 
 0
 None
 [2 2]
 Hello_World
 CharacterAnimationFacing
 &quot;String with quoted spaces.&quot;
 String_with_underscores_for_spaces.
 
 (* Molecule values *)

 []
 [Some 0]
 [Left 0]
 [[0 1] [2 4]]
 [AnimationData 4 8]
 [Gem `[Some 1]&apos;]

 ...and so on.
</summary>
</member>
<member name="M:Prime.SymbolModule.fromString(System.String)">
<summary>
 Convert a string to a symbol, with the following parses:
 
 (* Atom values *)
 
 0
 None
 [2 2]
 Hello_World
 CharacterAnimationFacing
 &quot;String with quoted spaces.&quot;
 String_with_underscores_for_spaces.
 
 (* Molecule values *)

 []
 [Some 0]
 [Left 0]
 [[0 1] [2 4]]
 [AnimationData 4 8]
 [Gem `[Some 1]&apos;]

 ...and so on.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.convertFromString(System.String,System.Type)">
<summary>
 Convert a value from a string using its assigned type converter.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.convertToString``1(``0)">
<summary>
 Convert a value to a string using its assigned type converter.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.convertFrom``1(``0,System.Type)">
<summary>
 Convert a value from given type using its assigned type converter.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.convertTo(System.Object,System.Type)">
<summary>
 Convert a value to the given type using its assigned type converter.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.canConvertFromString(System.Type)">
<summary>
 Query that a value of the destination type can be converted from a string.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.canConvertFrom(System.Type,System.Type)">
<summary>
 Query that a value of the destination type can be converted from the source type.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.canConvertToString(System.Type)">
<summary>
 Query that a value of the source type can be converted to a string.
</summary>
</member>
<member name="M:Prime.SymbolicDescriptor.canConvertTo(System.Type,System.Type)">
<summary>
 Query that a value of the source type can be converted to the destination type.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.symvalue``1(System.String)">
<summary>
 Uses an algebraic converter to convert a string to a value.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.symstring(System.Object)">
<summary>
 Uses an algebraic converter to convert a value to a string.
</summary>
</member>
<member name="M:Prime.Triple.make``3(``0,``1,``2)">
<summary>
 Make a triple.
</summary>
</member>
<member name="M:Prime.Triple.mapC``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``3,``0)">
<summary>
 Map over triple member c.
</summary>
</member>
<member name="M:Prime.Triple.mapB``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0,``3)">
<summary>
 Map over triple member b.
</summary>
</member>
<member name="M:Prime.Triple.mapA``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2,``3)">
<summary>
 Map over triple member a.
</summary>
</member>
<member name="M:Prime.Triple.withC``4(``0,``1,``2,``3)">
<summary>
 Replace triple member c.
</summary>
</member>
<member name="M:Prime.Triple.withB``4(``0,``1,``2,``3)">
<summary>
 Replace triple member b.
</summary>
</member>
<member name="M:Prime.Triple.withA``4(``0,``1,``2,``3)">
<summary>
 Replace triple member a.
</summary>
</member>
<member name="M:Prime.Triple.append``3(``0,``1,``2)">
<summary>
 Append an item to a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.insert``3(``0,``1,``2)">
<summary>
 Insert an item in a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.prepend``3(``0,``1,``2)">
<summary>
 Prepend an item to a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.thd``3">
<summary>
 The third item in a triple.
</summary>
</member>
<member name="M:Prime.Triple.snd``3">
<summary>
 The second item in a triple.
</summary>
</member>
<member name="M:Prime.Triple.fst``3">
<summary>
 The first item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators._bc``3(``0,``1,``2)">
<summary>
 The second and third items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.a_c``3(``0,``1,``2)">
<summary>
 The first and third items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.ab_``3(``0,``1,``2)">
<summary>
 The first and second items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.__c``3(``0,``1,``2)">
<summary>
 The third item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators._b_``3(``0,``1,``2)">
<summary>
 The second item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.a__``3(``0,``1,``2)">
<summary>
 The first item in a triple.
</summary>
</member>
<member name="M:Prime.Type.GetPropertyByPreference``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 TODO: document!
</summary>
</member>
<member name="M:Prime.Type.GetTypeUnqualified(System.String)">
<summary>
 Get an existing type with the given unqualified name. Time-intensive.
</summary>
</member>
<member name="M:Prime.Type.TryGetTypeUnqualified(System.String)">
<summary>
 Try to get an existing type with the given unqualified name. Time-intensive.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.TryGetCustomTypeConverter(System.Type)">
<summary>
 Try to get a custom type converter for the given type.
</summary>
</member>
<member name="M:Prime.VmapModule.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Convert a sequence of keys and values to a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.toSeq``2(Prime.Vmap{``0,``1})">
<summary>
 Convert a Vmap to a sequence of pairs of keys and values.
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
 Don&apos;t use it unless you need its laziness or if performance won&apos;t be affected significantly.
</summary>
</member>
<member name="M:Prime.VmapModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Vmap{``2,``0})">
<summary>
 Map over a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,Prime.Vmap{``1,``2})">
<summary>
 Fold over a Vmap.
</summary>
</member>
<member name="M:Prime.VmapModule.concat``2(Prime.Vmap{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in the case of a key
 conflict.
</summary>
</member>
<member name="M:Prime.VnodeModule.add``2(Prime.Hkv{``0,``1},Prime.Vnode{``0,``1}[],System.Int32,Prime.Vnode{``0,``1})">
<summary>
 OPTIMIZATION: Requires an empty array to use the source of new array clones in order to avoid Array.create.
</summary>
</member>
<member name="M:Prime.VnodeModule.toSeq``2(Prime.Vnode{``0,``1})">
<summary>
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
</summary>
</member>
<member name="M:Prime.VnodeModule.cloneArray``2(Prime.Vnode{``0,``1}[])">
<summary>
 OPTIMIZATION: Array.Clone () is not used since it&apos;s been profiled to be slower
</summary>
</member>
<member name="P:Prime.VsyncBuilderModule.vsync">
<summary>
 The VsyncBuilder instance.
 Used like: vsync { return 0 }
</summary>
</member>
<member name="M:Prime.VsyncModule.isSync">
<summary>
 Query whether Vsync is using synchronized or asynchronous processing.
</summary>
</member>
<member name="M:Prime.VsyncModule.init(System.Boolean)">
<summary>
 Initialize Vsync to use synchronized or asynchronous processing.
</summary>
</member>
<member name="P:Prime.VsyncModule.OptSync">
<summary>
 Configures whether to use synchronized processing.
</summary>
</member>
<member name="M:Prime.XtensionModule.make(System.Boolean,System.Boolean)">
<summary>
 Make an extension with custom safety.
</summary>
</member>
<member name="P:Prime.XtensionModule.mixed">
<summary>
 An Xtension that cannot default and isn&apos;t sealed.
</summary>
</member>
<member name="P:Prime.XtensionModule.safe">
<summary>
 An Xtension that cannot default and is sealed.
</summary>
</member>
<member name="P:Prime.XtensionModule.empty">
<summary>
 An Xtension that can default and isn&apos;t sealed.
</summary>
</member>
<member name="M:Seq.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check that a predicate passes for NO items in a sequence.
</summary>
</member>
<member name="M:Seq.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:Seq.project``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Project the first sequence onto the second.
</summary>
</member>
<member name="M:Seq.tryTake``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:Seq.fornone``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check if no elements satisfy a predicate in a seq.
</summary>
</member>
<member name="M:Seq.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)">
<summary>
 Fold-back for seqs.
</summary>
</member>
<member name="M:Seq.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Fold, now with a counter!
</summary>
</member>
<member name="M:Seq.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Fold with two inputs (plus state).
</summary>
</member>
<member name="M:Seq.definitize``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:Seq.headOrDefault``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Get a seq head or a default value if there is none.
</summary>
</member>
<member name="M:Seq.tryHead``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Get Some head of the seq or None.
</summary>
</member>
<member name="M:Set.addMany``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Add multiple values to a set.
</summary>
</member>
<member name="M:Set.singleton``1(``0)">
<summary>
 Make a singleton set.
</summary>
</member>
</members>
</doc>
